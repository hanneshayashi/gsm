Function Get-About {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "about"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets information about the user, the user's Drive, and system capabilities.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Delete-Asps {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CodeId,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CodeId  = @{ OriginalName = '--codeId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "asps"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete an ASP issued by a user.

.PARAMETER CodeId
The unique ID of the ASP


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Get-Asps {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CodeId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CodeId  = @{ OriginalName = '--codeId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "asps"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Get information about an ASP issued by a user.

.PARAMETER CodeId
The unique ID of the ASP


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function List-Asps {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "asps"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List the ASPs issued by a user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Get-Attachments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$MessageId,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id        = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MessageId = @{ OriginalName = '--messageId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId    = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "attachments"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified message attachment.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the attachment.


.PARAMETER MessageId
The ID of the message containing the attachment.


.PARAMETER UserId
The user's email address.
The special value me can be used to indicate the authenticated user.



#>
}


Function Delete-CalendarAcl {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$RuleId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RuleId     = @{ OriginalName = '--ruleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarAcl"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes an access control rule.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarAcl.acl method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER RuleId
ACL rule identifier.



#>
}


Function Get-CalendarAcl {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RuleId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RuleId     = @{ OriginalName = '--ruleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarAcl"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns an access control rule.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarAcl.acl method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RuleId
ACL rule identifier.



#>
}


Function Insert-CalendarAcl {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Role,
        [Parameter()]
        [string]$ScopeType,
        [Parameter()]
        [string]$ScopeValue,
        [Parameter()]
        [switch]$SendNotifications
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId        = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Role              = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ScopeType         = @{ OriginalName = '--scopeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ScopeValue        = @{ OriginalName = '--scopeValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendNotifications = @{ OriginalName = '--sendNotifications'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarAcl"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates an access control rule.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarAcl.acl method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Role
The role assigned to the scope. Possible values are:
"none" - Provides no access.
"freeBusyReader" - Provides read access to free/busy information.
"reader" - Provides read access to the calendar. Private events will appear to users with reader access, but event details will be hidden.
"writer" - Provides read and write access to the calendar. Private events will appear to users with writer access, and event details will be visible.
"owner" - Provides ownership of the calendar. This role has all of the permissions of the writer role with the additional ability to see and manipulate ACLs.


.PARAMETER ScopeType
The type of the scope. Possible values are:
"default" - The public scope. This is the default value.
"user" - Limits the scope to a single user.
"group" - Limits the scope to a group.
"domain" - Limits the scope to a domain.
Note: The permissions granted to the "default", or public, scope apply to any user, authenticated or not.


.PARAMETER ScopeValue
The email address of a user or group, or the name of a domain, depending on the scope type.
Omitted for type "default".


.PARAMETER SendNotifications
Whether to send notifications about the calendar sharing change.
Optional. The default is True.



#>
}


Function List-CalendarAcl {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$ShowDeleted
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId  = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ShowDeleted = @{ OriginalName = '--showDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarAcl"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the rules in the access control list for the calendar.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarAcl.acl method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ShowDeleted
Whether to include deleted ACLs in the result.
Deleted ACLs are represented by role equal to "none".
Deleted ACLs will always be included if syncToken is provided.



#>
}


Function Patch-CalendarAcl {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Role,
        [Parameter()]
        [string]$RuleId,
        [Parameter()]
        [string]$ScopeType,
        [Parameter()]
        [string]$ScopeValue,
        [Parameter()]
        [switch]$SendNotifications
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId        = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Role              = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RuleId            = @{ OriginalName = '--ruleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ScopeType         = @{ OriginalName = '--scopeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ScopeValue        = @{ OriginalName = '--scopeValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendNotifications = @{ OriginalName = '--sendNotifications'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarAcl"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates an access control rule. This method supports patch semantics.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarAcl.acl method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Role
The role assigned to the scope. Possible values are:
"none" - Provides no access.
"freeBusyReader" - Provides read access to free/busy information.
"reader" - Provides read access to the calendar. Private events will appear to users with reader access, but event details will be hidden.
"writer" - Provides read and write access to the calendar. Private events will appear to users with writer access, and event details will be visible.
"owner" - Provides ownership of the calendar. This role has all of the permissions of the writer role with the additional ability to see and manipulate ACLs.


.PARAMETER RuleId
ACL rule identifier.


.PARAMETER ScopeType
The type of the scope. Possible values are:
"default" - The public scope. This is the default value.
"user" - Limits the scope to a single user.
"group" - Limits the scope to a group.
"domain" - Limits the scope to a domain.
Note: The permissions granted to the "default", or public, scope apply to any user, authenticated or not.


.PARAMETER ScopeValue
The email address of a user or group, or the name of a domain, depending on the scope type.
Omitted for type "default".


.PARAMETER SendNotifications
Whether to send notifications about the calendar sharing change.
Optional. The default is True.



#>
}


Function Delete-CalendarLists {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarLists"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes a calendar from the user's calendar list.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.



#>
}


Function Get-CalendarLists {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarLists"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns a calendar from the user's calendar list.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-CalendarLists {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BackgroundColor,
        [Parameter()]
        [string]$ColorId,
        [Parameter()]
        [switch]$ColorRgbFormat,
        [Parameter()]
        [string]$DefaultReminders,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ForegroundColor,
        [Parameter()]
        [switch]$Hidden,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$NotificationsType,
        [Parameter()]
        [switch]$Selected,
        [Parameter()]
        [string]$SummaryOverride
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BackgroundColor   = @{ OriginalName = '--backgroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorId           = @{ OriginalName = '--colorId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorRgbFormat    = @{ OriginalName = '--colorRgbFormat'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            DefaultReminders  = @{ OriginalName = '--defaultReminders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ForegroundColor   = @{ OriginalName = '--foregroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Hidden            = @{ OriginalName = '--hidden'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Id                = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotificationsType = @{ OriginalName = '--notificationsType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Selected          = @{ OriginalName = '--selected'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            SummaryOverride   = @{ OriginalName = '--summaryOverride'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarLists"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts an existing calendar into the user's calendar list.

.PARAMETER BackgroundColor
The main color of the calendar in the hexadecimal format "#0088aa".
This property supersedes the index-based colorId property.
To set or change this property, you need to specify colorRgbFormat=true in the parameters of the insert, update and patch methods.


.PARAMETER ColorId
The color of the calendar.
This is an ID referring to an entry in the calendar section of the colors definition (see the colors endpoint).
This property is superseded by the backgroundColor and foregroundColor properties and can be ignored when using these properties.


.PARAMETER ColorRgbFormat
Whether to use the foregroundColor and backgroundColor fields to write the calendar colors (RGB).
If this feature is used, the index-based colorId field will be set to the best matching option automatically.


.PARAMETER DefaultReminders
The default reminders that the authenticated user has for this calendar.
Must be given in the form of '--defaultReminders "method=[popup|email];minutes[0-40320]
Where
email  - Reminders are sent via email.
popup  - Reminders are sent via a UI popup.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ForegroundColor
The foreground color of the calendar in the hexadecimal format "#ffffff".
This property supersedes the index-based colorId property.
To set or change this property, you need to specify colorRgbFormat=true in the parameters of the insert, update and patch methods.


.PARAMETER Hidden
Whether the calendar has been hidden from the list.


.PARAMETER Id
Identifier of the calendar.


.PARAMETER NotificationsType
The type of notification.
[eventCreation|eventChange|eventCancellation|eventResponse|agenda]
eventCreation      - Notification sent when a new event is put on the calendar.
eventChange        - Notification sent when an event is changed.
eventCancellation  - Notification sent when an event is cancelled.
eventResponse      - Notification sent when an attendee responds to the event invitation.
agenda             - An agenda with the events of the day (sent out in the morning).
Note that all notifications are sent via email ("method" is always set to "email" atomatically)


.PARAMETER Selected
Whether the calendar content shows up in the calendar UI


.PARAMETER SummaryOverride
The summary that the authenticated user has set for this calendar.



#>
}


Function List-CalendarLists {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MinAccessRole,
        [Parameter()]
        [switch]$ShowDeleted,
        [Parameter()]
        [switch]$ShowHidden
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId    = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MinAccessRole = @{ OriginalName = '--minAccessRole'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ShowDeleted   = @{ OriginalName = '--showDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ShowHidden    = @{ OriginalName = '--showHidden'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarLists"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the calendars on the user's calendar list.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MinAccessRole
The minimum access role for the user in the returned entries.
Optional. The default is no restriction.
[freeBusyReader|owner|reader|writer]
freeBusyReader  - The user can read free/busy information.
owner           - The user can read and modify events and access control lists.
reader          - The user can read events that are not private.
writer          - The user can read and modify events.


.PARAMETER ShowDeleted
Whether to include deleted calendar list entries in the result.


.PARAMETER ShowHidden
Whether to show hidden entries.



#>
}


Function Patch-CalendarLists {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BackgroundColor,
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$ColorId,
        [Parameter()]
        [switch]$ColorRgbFormat,
        [Parameter()]
        [string]$DefaultReminders,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ForegroundColor,
        [Parameter()]
        [switch]$Hidden,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$NotificationsType,
        [Parameter()]
        [switch]$Selected,
        [Parameter()]
        [string]$SummaryOverride
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BackgroundColor   = @{ OriginalName = '--backgroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CalendarId        = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorId           = @{ OriginalName = '--colorId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorRgbFormat    = @{ OriginalName = '--colorRgbFormat'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            DefaultReminders  = @{ OriginalName = '--defaultReminders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ForegroundColor   = @{ OriginalName = '--foregroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Hidden            = @{ OriginalName = '--hidden'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Id                = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotificationsType = @{ OriginalName = '--notificationsType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Selected          = @{ OriginalName = '--selected'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            SummaryOverride   = @{ OriginalName = '--summaryOverride'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarLists"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates an existing calendar on the user's calendar list. This method supports patch semantics.

.PARAMETER BackgroundColor
The main color of the calendar in the hexadecimal format "#0088aa".
This property supersedes the index-based colorId property.
To set or change this property, you need to specify colorRgbFormat=true in the parameters of the insert, update and patch methods.


.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER ColorId
The color of the calendar.
This is an ID referring to an entry in the calendar section of the colors definition (see the colors endpoint).
This property is superseded by the backgroundColor and foregroundColor properties and can be ignored when using these properties.


.PARAMETER ColorRgbFormat
Whether to use the foregroundColor and backgroundColor fields to write the calendar colors (RGB).
If this feature is used, the index-based colorId field will be set to the best matching option automatically.


.PARAMETER DefaultReminders
The default reminders that the authenticated user has for this calendar.
Must be given in the form of '--defaultReminders "method=[popup|email];minutes[0-40320]
Where
email  - Reminders are sent via email.
popup  - Reminders are sent via a UI popup.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ForegroundColor
The foreground color of the calendar in the hexadecimal format "#ffffff".
This property supersedes the index-based colorId property.
To set or change this property, you need to specify colorRgbFormat=true in the parameters of the insert, update and patch methods.


.PARAMETER Hidden
Whether the calendar has been hidden from the list.


.PARAMETER Id
Identifier of the calendar.


.PARAMETER NotificationsType
The type of notification.
[eventCreation|eventChange|eventCancellation|eventResponse|agenda]
eventCreation      - Notification sent when a new event is put on the calendar.
eventChange        - Notification sent when an event is changed.
eventCancellation  - Notification sent when an event is cancelled.
eventResponse      - Notification sent when an attendee responds to the event invitation.
agenda             - An agenda with the events of the day (sent out in the morning).
Note that all notifications are sent via email ("method" is always set to "email" atomatically)


.PARAMETER Selected
Whether the calendar content shows up in the calendar UI


.PARAMETER SummaryOverride
The summary that the authenticated user has set for this calendar.



#>
}


Function Clear-Calendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendars"
            "clear"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Clears a primary calendar.
This operation deletes all events associated with the primary calendar of an account.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.



#>
}


Function Delete-Calendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendars"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a secondary calendar.
Use calendars.clear for clearing all events on primary calendars.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.



#>
}


Function Get-Calendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendars"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns metadata for a calendar.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-Calendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Location,
        [Parameter()]
        [string]$Summary,
        [Parameter()]
        [string]$TimeZone
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Description = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Location    = @{ OriginalName = '--location'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Summary     = @{ OriginalName = '--summary'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone    = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendars"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a secondary calendar.

.PARAMETER Description
Description of the calendar.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Location
Geographic location of the calendar as free-form text.


.PARAMETER Summary
Title of the calendar.


.PARAMETER TimeZone
The time zone of the calendar.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich").



#>
}


Function Patch-Calendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Location,
        [Parameter()]
        [string]$Summary,
        [Parameter()]
        [string]$TimeZone
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId  = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Location    = @{ OriginalName = '--location'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Summary     = @{ OriginalName = '--summary'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone    = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendars"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a secondary calendar.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Description
Description of the calendar.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Location
Geographic location of the calendar as free-form text.


.PARAMETER Summary
Title of the calendar.


.PARAMETER TimeZone
The time zone of the calendar.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich").



#>
}


Function Get-CalendarSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Setting
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Setting = @{ OriginalName = '--setting'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarSettings"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns a single user setting.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Setting
The id of the user setting.



#>
}


Function List-CalendarSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "calendarSettings"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns an setting.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function GetStartPageToken-Changes {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "changes"
            "getStartPageToken"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the starting pageToken for listing future changes.

.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function List-Changes {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeCorpusRemovals,
        [Parameter()]
        [switch]$IncludeItemsFromAllDrives,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [switch]$IncludeRemoved,
        [Parameter()]
        [string]$PageToken,
        [Parameter()]
        [switch]$RestrictToMyDrive,
        [Parameter()]
        [string]$Spaces
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId                   = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeCorpusRemovals     = @{ OriginalName = '--includeCorpusRemovals'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludeItemsFromAllDrives = @{ OriginalName = '--includeItemsFromAllDrives'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludePermissionsForView = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeRemoved            = @{ OriginalName = '--includeRemoved'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            PageToken                 = @{ OriginalName = '--pageToken'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RestrictToMyDrive         = @{ OriginalName = '--restrictToMyDrive'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Spaces                    = @{ OriginalName = '--spaces'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "changes"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the changes for a user or shared drive.

.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeCorpusRemovals
Whether changes should include the file resource if the file is still accessible by the user at the time of the request, even when a file was removed from the list of changes and there will be no further change entries for this file.


.PARAMETER IncludeItemsFromAllDrives
Whether both My Drive and shared drive items should be included in results.


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER IncludeRemoved
Whether to include changes indicating that items have been removed from the list of changes, for example by deletion or loss of access.


.PARAMETER PageToken
The token for continuing a previous list request on the next page.
This should be set to the value of 'nextPageToken' from the previous response or to the response from the getStartPageToken method.


.PARAMETER RestrictToMyDrive
Whether to restrict the results to changes inside the My Drive hierarchy.
This omits changes to files such as those in the Application Data folder or shared files which have not been added to My Drive.


.PARAMETER Spaces
A comma-separated list of spaces to query within the user corpus. Supported values are 'drive', 'appDataFolder' and 'photos'.



#>
}


Function IssueCommand-ChromeOs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommandType,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DeviceId,
        [Parameter()]
        [string]$Payload
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommandType = @{ OriginalName = '--commandType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DeviceId    = @{ OriginalName = '--deviceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Payload     = @{ OriginalName = '--payload'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOs"
            "issueCommand"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Takes an issueCommand that affects a Chrome OS Device. This includes deprovisioning, disabling, and re-enabling devices.

.PARAMETER CommandType
The type of command.

Acceptable values are:
REBOOT             - Reboot the device.
                     Can only be issued to Kiosk and managed guest session devices.
TAKE_A_SCREENSHOT  - Take a screenshot of the device.
                     Only available if the device is in Kiosk Mode.
SET_VOLUME         - Set the volume of the device.
                     Can only be issued to Kiosk and managed guest session devices.
WIPE_USERS         - Wipe all the users off of the device.
                     Executing this command in the device will remove all user profile data, but it will keep device policy and enrollment.
REMOTE_POWERWASH   - Wipes the device by performing a power wash.
					 Executing this command in the device will remove all data including user policies, device policies and enrollment policies.
					 Warning: This will revert the device back to a factory state with no enrollment unless the device is subject to forced or auto enrollment.
					 Use with caution, as this is an irreversible action!


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER DeviceId
Immutable ID of Chrome OS Device.


.PARAMETER Payload
The payload for the command, provide it only if command supports it. The following commands support adding payload: - SET_VOLUME: Payload is a stringified JSON object in the form: { "volume": 50 }. The volume has to be an integer in the range [0,100].



#>
}


Function Action-ChromeOsDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Action,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DeprovisionReason,
        [Parameter()]
        [string]$ResourceId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Action            = @{ OriginalName = '--action'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerId        = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DeprovisionReason = @{ OriginalName = '--deprovisionReason'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceId        = @{ OriginalName = '--resourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOsDevices"
            "action"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Takes an action that affects a Chrome OS Device. This includes deprovisioning, disabling, and re-enabling devices.

.PARAMETER Action
Action to be taken on the Chrome OS device

Acceptable values are:
deprovision  - Remove a device from management that is no longer active, being resold, or is being submitted for return / repair, use the deprovision action to dissociate it from management.
disable      - If you believe a device in your organization has been lost or stolen, you can disable the device so that no one else can use it.
               When a device is disabled, all the user can see when turning on the Chrome device is a screen telling them that it has been disabled, and your desired contact information of where to return the device.
               Note: Configuration of the message to appear on a disabled device must be completed within the admin console.
 reenable    - Re-enable a disabled device when a misplaced device is found or a lost device is returned. You can also use this feature if you accidentally mark a Chrome device as disabled.
               Note: The re-enable action can only be performed on devices marked as disabled.


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER DeprovisionReason
Only used when the action is deprovision. With the deprovision action, this field is required.

Note: The deprovision reason is audited because it might have implications on licenses for perpetual subscription customers.

Acceptable values are:
different_model_replacement  - Use if you're upgrading or replacing your device with a newer model of the same device.
retiring_device              - Use if you're reselling, donating, or permanently removing the device from use.
same_model_replacement       - Use if a hardware issue was encountered on a device and it is being replaced with the same model or a like-model replacement from a repair vendor / manufacturer.
upgrade_transfer             - Use if you're replacing your Cloud Ready devices with Chromebooks within one year.


.PARAMETER ResourceId
The unique ID of the device.
The resourceIds are returned in the response from the chromeosdevices.list method.



#>
}


Function Get-ChromeOsDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DeviceId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Projection
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DeviceId   = @{ OriginalName = '--deviceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOsDevices"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a Chrome OS device's properties.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER DeviceId
The unique ID of the device.
The deviceIds are returned in the response from the chromeosdevices.list method.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Projection
Determines whether the response contains the full list of properties or only a subset.

Acceptable values are:
BASIC  - Excludes the model, meid, orderNumber, willAutoRenew, osVersion, platformVersion, firmwareVersion, macAddress, and bootMode properties.
FULL   - Includes all metadata fields.



#>
}


Function List-ChromeOsDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$Projection,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$SortOrder
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy     = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection  = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query       = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SortOrder   = @{ OriginalName = '--sortOrder'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOsDevices"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of Chrome OS devices within an account.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrderBy
Device property to use for sorting results.

Acceptable values are:
annotatedLocation  - Chrome device location as annotated by the administrator.
annotatedUser      - Chrome device user as annotated by the administrator.
lastSync           - The date and time the Chrome device was last synchronized with the policy settings in the Admin console.
notes              - Chrome device notes as annotated by the administrator.
serialNumber       - The Chrome device serial number entered when the device was enabled.
status             - Chrome device status. For more information, see the chromeosdevices resource.
supportEndDate     - Chrome device support end date. This is applicable only for devices purchased directly from Google.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.


.PARAMETER Projection
Determines whether the response contains the full list of properties or only a subset.

Acceptable values are:
BASIC  - Excludes the model, meid, orderNumber, willAutoRenew, osVersion, platformVersion, firmwareVersion, macAddress, and bootMode properties.
FULL   - Includes all metadata fields.


.PARAMETER Query
Search string in the format provided by List query operators
(https://developers.google.com/admin-sdk/directory/v1/list-query-operators).


.PARAMETER SortOrder
Whether to return results in ascending or descending order. Must be used with the orderBy parameter.

Acceptable values are:
ASCENDING   - Ascending order.
DESCENDING  - Descending order.



#>
}


Function MoveToOU-ChromeOsDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DeviceIds,
        [Parameter()]
        [string]$OrgUnitPath
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DeviceIds   = @{ OriginalName = '--deviceIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOsDevices"
            "moveToOU"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Move or insert multiple Chrome OS devices to an organizational unit. You can move up to 50 devices at once.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER DeviceIds
Chrome OS devices to be moved to OU


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.



#>
}


Function Patch-ChromeOsDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AnnotatedAssetId,
        [Parameter()]
        [string]$AnnotatedLocation,
        [Parameter()]
        [string]$AnnotatedUser,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DeviceId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Notes,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$Projection
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AnnotatedAssetId  = @{ OriginalName = '--annotatedAssetId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AnnotatedLocation = @{ OriginalName = '--annotatedLocation'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AnnotatedUser     = @{ OriginalName = '--annotatedUser'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerId        = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DeviceId          = @{ OriginalName = '--deviceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Notes             = @{ OriginalName = '--notes'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath       = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection        = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "chromeOsDevices"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a device's updatable properties, such as annotatedUser, annotatedLocation, notes, orgUnitPath, or annotatedAssetId. This method supports patch semantics

.PARAMETER AnnotatedAssetId
The asset identifier as noted by an administrator or specified during enrollment.


.PARAMETER AnnotatedLocation
The address or location of the device as noted by the administrator.
Maximum length is 200 characters. Empty values are allowed.


.PARAMETER AnnotatedUser
The user of the device as noted by the administrator.
Maximum length is 100 characters. Empty values are allowed.


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER DeviceId
The unique ID of the device.
The deviceIds are returned in the response from the chromeosdevices.list method.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Notes
Notes about this device added by the administrator.
This property can be searched with the list method's query parameter.
Maximum length is 500 characters. Empty values are allowed.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.


.PARAMETER Projection
Determines whether the response contains the full list of properties or only a subset.

Acceptable values are:
BASIC  - Excludes the model, meid, orderNumber, willAutoRenew, osVersion, platformVersion, firmwareVersion, macAddress, and bootMode properties.
FULL   - Includes all metadata fields.



#>
}


Function Get-Colors {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "colors"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the color definitions for calendars and events.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Create-Comments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Anchor,
        [Parameter()]
        [string]$Content,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$QuotedFileContentValue
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Anchor                 = @{ OriginalName = '--anchor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Content                = @{ OriginalName = '--content'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                 = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                 = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            QuotedFileContentValue = @{ OriginalName = '--quotedFileContentValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "comments"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new comment on a file.

.PARAMETER Anchor
A region of the document represented as a JSON string.
See anchor documentation for details on how to define and interpret anchor properties.


.PARAMETER Content
The plain text content of the comment.
This field is used for setting the content, while htmlContent should be displayed.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER QuotedFileContentValue
The quoted content itself.
This is interpreted as plain text if set through the API.



#>
}


Function Delete-Comments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "comments"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a comment.

.PARAMETER CommentId
The ID of the comment.


.PARAMETER FileId
The ID of the file.



#>
}


Function Get-Comments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [switch]$IncludeDeleted
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommentId      = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId         = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeDeleted = @{ OriginalName = '--includeDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "comments"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a comment by ID.

.PARAMETER CommentId
The ID of the comment.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER IncludeDeleted
Whether to return deleted comments.
Deleted comments will not include their original content.



#>
}


Function List-Comments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [switch]$IncludeDeleted,
        [Parameter()]
        [string]$StartModifiedTime
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId            = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeDeleted    = @{ OriginalName = '--includeDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            StartModifiedTime = @{ OriginalName = '--startModifiedTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "comments"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists a file's comments.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER IncludeDeleted
Whether to return deleted comments.
Deleted comments will not include their original content.


.PARAMETER StartModifiedTime
The minimum value of 'modifiedTime' for the result comments (RFC 3339 date-time).



#>
}


Function Update-Comments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Anchor,
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Content,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$QuotedFileContentValue
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Anchor                 = @{ OriginalName = '--anchor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CommentId              = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Content                = @{ OriginalName = '--content'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                 = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                 = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            QuotedFileContentValue = @{ OriginalName = '--quotedFileContentValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "comments"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a comment with patch semantics.

.PARAMETER Anchor
A region of the document represented as a JSON string.
See anchor documentation for details on how to define and interpret anchor properties.


.PARAMETER CommentId
The ID of the comment.


.PARAMETER Content
The plain text content of the comment.
This field is used for setting the content, while htmlContent should be displayed.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER QuotedFileContentValue
The quoted content itself.
This is interpreted as plain text if set through the API.



#>
}


Function Get-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Name = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Return a single GSM config

.PARAMETER Name
Name of the configuration.
This (plus ".yaml") will be used as the file name.



#>
}


Function GetScopes-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Name = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "getScopes"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the scopes of a config file so they can be easily added in the Admin Console

.PARAMETER Name
Name of the configuration.
This (plus ".yaml") will be used as the file name.



#>
}


Function List-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$Details
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Details = @{ OriginalName = '--details'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List current configurations

.PARAMETER Details
List detailed information about configs.



#>
}


Function Load-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Name = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "load"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Load a config file

.PARAMETER Name
Name of the configuration.
This (plus ".yaml") will be used as the file name.



#>
}


Function New-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CredentialsFile,
        [Parameter()]
        [string]$Mode,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$Scopes,
        [Parameter()]
        [string]$StandardDelay,
        [Parameter()]
        [string]$Subject,
        [Parameter()]
        [string]$Threads
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CredentialsFile = @{ OriginalName = '--credentialsFile'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Mode            = @{ OriginalName = '--mode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name            = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Scopes          = @{ OriginalName = '--scopes'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StandardDelay   = @{ OriginalName = '--standardDelay'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Subject         = @{ OriginalName = '--subject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Threads         = @{ OriginalName = '--threads'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "new"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Create a new config file.

.PARAMETER CredentialsFile
Path to the credential file.
Can be relative to the binary or fully qualified.


.PARAMETER Mode
The mode to operate in. Can be:
[dwd|user]


.PARAMETER Name
Name of the configuration.
This (plus ".yaml") will be used as the file name.


.PARAMETER Scopes
OAuth Scopes to use.


.PARAMETER StandardDelay
Delay in ms to wait after each API call


.PARAMETER Subject
The user who should be impersonated with DWD.


.PARAMETER Threads
The maximum number of threads to use.



#>
}


Function Remove-Configs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Name = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "configs"
            "remove"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes a configuration

.PARAMETER Name
Name of the configuration.
This (plus ".yaml") will be used as the file name.



#>
}


Function BatchGet-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MaxMembers,
        [Parameter()]
        [string]$ResourceNames
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxMembers    = @{ OriginalName = '--maxMembers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceNames = @{ OriginalName = '--resourceNames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "batchGet"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Get a list of contact groups owned by the authenticated user by specifying a list of contact group resource names.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MaxMembers
Specifies the maximum number of members to return for each group.
Defaults to 0 if not set, which will return zero members.


.PARAMETER ResourceNames
The resource names of the contact groups.



#>
}


Function Create-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name   = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Create a new contact group owned by the authenticated user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The contact group name set by the group owner or a system provided name for system groups.



#>
}


Function Delete-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$DeleteContacts,
        [Parameter()]
        [string]$ResourceName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DeleteContacts = @{ OriginalName = '--deleteContacts'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ResourceName   = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete an existing contact group owned by the authenticated user by specifying a contact group resource name.

.PARAMETER DeleteContacts
Set to true to also delete the contacts in the specified group.


.PARAMETER ResourceName
The resource name of the contact group.



#>
}


Function Get-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MaxMembers,
        [Parameter()]
        [string]$ResourceName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxMembers   = @{ OriginalName = '--maxMembers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Get a specific contact group owned by the authenticated user by specifying a contact group resource name.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MaxMembers
Specifies the maximum number of members to return for each group.
Defaults to 0 if not set, which will return zero members.


.PARAMETER ResourceName
The resource name of the contact group.



#>
}


Function List-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List all contact groups owned by the authenticated user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Update-ContactGroups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$ResourceName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name         = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroups"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Update the name of an existing contact group owned by the authenticated user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The contact group name set by the group owner or a system provided name for system groups.


.PARAMETER ResourceName
The resource name of the contact group.



#>
}


Function Modify-ContactGroupsMembers {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$ResourceNamesToAdd,
        [Parameter()]
        [string]$ResourceNamesToRemove
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName          = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceNamesToAdd    = @{ OriginalName = '--resourceNamesToAdd'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceNamesToRemove = @{ OriginalName = '--resourceNamesToRemove'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "contactGroupsMembers"
            "modify"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Modify a new contact group owned by the authenticated user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ResourceName
The resource name of the contact group to modify.


.PARAMETER ResourceNamesToAdd
The resource names of the contact people to add in the form of people/{person_id}.


.PARAMETER ResourceNamesToRemove
The resource names of the contact people to remove in the form of people/{person_id}.



#>
}


Function Get-Customers {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerKey,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerKey = @{ OriginalName = '--customerKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "customers"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a customer using a an ID or retrieve your own customer without knowing your ID.

.PARAMETER CustomerKey
Id of the customer.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-Customers {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddressLine1,
        [Parameter()]
        [string]$AddressLine2,
        [Parameter()]
        [string]$AddressLine3,
        [Parameter()]
        [string]$AlternateEmail,
        [Parameter()]
        [string]$ContactName,
        [Parameter()]
        [string]$CountryCode,
        [Parameter()]
        [string]$CustomerDomain,
        [Parameter()]
        [string]$CustomerKey,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Language,
        [Parameter()]
        [string]$Locality,
        [Parameter()]
        [string]$OrganizationName,
        [Parameter()]
        [string]$PhoneNumber,
        [Parameter()]
        [string]$PostalCode,
        [Parameter()]
        [string]$Region
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddressLine1     = @{ OriginalName = '--addressLine1'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AddressLine2     = @{ OriginalName = '--addressLine2'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AddressLine3     = @{ OriginalName = '--addressLine3'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AlternateEmail   = @{ OriginalName = '--alternateEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ContactName      = @{ OriginalName = '--contactName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CountryCode      = @{ OriginalName = '--countryCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerDomain   = @{ OriginalName = '--customerDomain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerKey      = @{ OriginalName = '--customerKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Language         = @{ OriginalName = '--language'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locality         = @{ OriginalName = '--locality'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrganizationName = @{ OriginalName = '--organizationName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneNumber      = @{ OriginalName = '--phoneNumber'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PostalCode       = @{ OriginalName = '--postalCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Region           = @{ OriginalName = '--region'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "customers"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a customer. This method supports patch semantics.

.PARAMETER AddressLine1
A customer's physical address.
The address can be composed of one to three lines.


.PARAMETER AddressLine2
Address line 2 of the address.


.PARAMETER AddressLine3
Address line 3 of the address.


.PARAMETER AlternateEmail
The customer's secondary contact email address.
This email address cannot be on the same domain as the customerDomain


.PARAMETER ContactName
The customer contact's name.


.PARAMETER CountryCode
This is a required property.
For countryCode information see the ISO 3166 country code elements.(http://www.iso.org/iso/country_codes.htm)


.PARAMETER CustomerDomain
The customer's primary domain name string.
Do not include the www prefix when creating a new customer.


.PARAMETER CustomerKey
Id of the customer.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Language
The customer's ISO 639-2 language code.
See the Language Codes page for the list of supported codes.
Valid language codes outside the supported set will be accepted by the API but may lead to unexpected behavior.
The default value is en.


.PARAMETER Locality
Name of the locality.
An example of a locality value is the city of San Francisco.


.PARAMETER OrganizationName
The company or company division name.


.PARAMETER PhoneNumber
The customer's contact phone number in E.164 format.


.PARAMETER PostalCode
The postal code. A postalCode example is a postal zip code such as 10009.
This is in accordance with - http://portablecontacts.net/draft-spec.html#address_element.


.PARAMETER Region
Name of the region.
An example of a region value is NY for the state of New York.



#>
}


Function Create-Delegates {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DelegateEmail,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DelegateEmail = @{ OriginalName = '--delegateEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId        = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "delegates"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds a delegate with its verification status set directly to accepted, without sending any verification email.

.PARAMETER DelegateEmail
The email address of the delegate.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Delete-Delegates {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DelegateEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DelegateEmail = @{ OriginalName = '--delegateEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId        = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "delegates"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes the specified delegate

.PARAMETER DelegateEmail
The email address of the delegate.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Get-Delegates {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DelegateEmail,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DelegateEmail = @{ OriginalName = '--delegateEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId        = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "delegates"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified delegate.

.PARAMETER DelegateEmail
The email address of the delegate.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function List-Delegates {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "delegates"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the delegates for the specified account.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Delete-DomainAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainAliasName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer        = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainAliasName = @{ OriginalName = '--domainAliasName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domainAliases"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a Domain Alias of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainAliasName
Name of domain alias.



#>
}


Function Get-DomainAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainAliasName,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer        = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainAliasName = @{ OriginalName = '--domainAliasName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domainAliases"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a domain alias of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainAliasName
Name of domain alias.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-DomainAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainAliasName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ParentDomainName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer         = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainAliasName  = @{ OriginalName = '--domainAliasName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentDomainName = @{ OriginalName = '--parentDomainName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domainAliases"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts a Domain alias of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainAliasName
Name of domain alias.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ParentDomainName
Name of domain alias.



#>
}


Function List-DomainAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ParentDomainName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer         = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentDomainName = @{ OriginalName = '--parentDomainName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domainAliases"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the domain aliases of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ParentDomainName
Name of domain alias.



#>
}


Function Delete-Domains {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainName = @{ OriginalName = '--domainName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domains"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a Domain  of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainName
Name of domain .



#>
}


Function Get-Domains {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainName,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainName = @{ OriginalName = '--domainName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domains"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a domain of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainName
Name of domain .


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-Domains {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$DomainName,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DomainName = @{ OriginalName = '--domainName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domains"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts a Domain of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER DomainName
Name of domain .


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function List-Domains {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "domains"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the domain  of the customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Create-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Bcc,
        [Parameter()]
        [string]$Body,
        [Parameter()]
        [string]$Cc,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Subject,
        [Parameter()]
        [string]$To,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Bcc     = @{ OriginalName = '--bcc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Body    = @{ OriginalName = '--body'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Cc      = @{ OriginalName = '--cc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Subject = @{ OriginalName = '--subject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            To      = @{ OriginalName = '--to'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId  = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new draft with the DRAFT label.

.PARAMETER Bcc
Blind Copy (Bcc)


.PARAMETER Body
Body or content of the (draft) message


.PARAMETER Cc
Copy (Cc)


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Subject
Subject of the (draft) message


.PARAMETER To
Recipient of the (draft) message


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Immediately and permanently deletes the specified draft. Does not simply trash it.

.PARAMETER Id
The ID of the draft.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Get-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Format,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Format = @{ OriginalName = '--format'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified draft.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Format
The format to return the draft in.
"[MINIMAL|FULL|RAW|METADATA].
MINIMAL   - Returns only email message ID and labels; does not return the email headers, body, or payload.
FULL      - Returns the full email message data with body content parsed in the payload field; the raw field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
RAW       - Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
METADATA  - Returns only email message ID, labels, and email headers.


.PARAMETER Id
The ID of the draft.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function List-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeSpamTrash,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeSpamTrash = @{ OriginalName = '--includeSpamTrash'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Q                = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId           = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the drafts in the user's mailbox.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeSpamTrash
Include drafts from SPAM and TRASH in the results.


.PARAMETER Q
Only return draft messages matching the specified query.
Supports the same query format as the Gmail search box.
For example, "from:someuser@example.com rfc822msgid:<somemsgid@example.com> is:unread".


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Send-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "send"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Sends the specified, existing draft to the recipients in the To, Cc, and Bcc headers.

.PARAMETER Id
The ID of the draft.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Update-Drafts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Bcc,
        [Parameter()]
        [string]$Body,
        [Parameter()]
        [string]$Cc,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$Subject,
        [Parameter()]
        [string]$To,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Bcc     = @{ OriginalName = '--bcc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Body    = @{ OriginalName = '--body'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Cc      = @{ OriginalName = '--cc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id      = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Subject = @{ OriginalName = '--subject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            To      = @{ OriginalName = '--to'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId  = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drafts"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Replaces a draft's content.

.PARAMETER Bcc
Blind Copy (Bcc)


.PARAMETER Body
Body or content of the (draft) message


.PARAMETER Cc
Copy (Cc)


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the draft.


.PARAMETER Subject
Subject of the (draft) message


.PARAMETER To
Recipient of the (draft) message


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Create-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AdminManagedRestrictions,
        [Parameter()]
        [switch]$CopyRequiresWriterPermission,
        [Parameter()]
        [switch]$DomainUsersOnly,
        [Parameter()]
        [switch]$DriveMembersOnly,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$ThemeId,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AdminManagedRestrictions     = @{ OriginalName = '--adminManagedRestrictions'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CopyRequiresWriterPermission = @{ OriginalName = '--copyRequiresWriterPermission'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            DomainUsersOnly              = @{ OriginalName = '--domainUsersOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            DriveMembersOnly             = @{ OriginalName = '--driveMembersOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields                       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                         = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThemeId                      = @{ OriginalName = '--themeId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess         = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new shared drive.

.PARAMETER AdminManagedRestrictions
Whether administrative privileges on this shared drive are required to modify restrictions


.PARAMETER CopyRequiresWriterPermission
Whether the options to copy, print, or download files inside this shared drive, should be disabled for readers and commenters. When this restriction is set to true, it will override the similarly named field to true for any file inside this shared drive


.PARAMETER DomainUsersOnly
Whether access to this shared drive and items inside this shared drive is restricted to users of the domain to which this shared drive belongs. This restriction may be overridden by other sharing policies controlled outside of this shared drive


.PARAMETER DriveMembersOnly
Whether access to items inside this shared drive is restricted to its members


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The name of this shared drive


.PARAMETER ThemeId
The ID of the theme from which the background image and color will be set.
The set of possible driveThemes can be retrieved from a drive.about.get response.
When not specified on a drive.drives.create request, a random theme is chosen from which the background image and color are set.
This is a write-only field; it can only be set on requests that don't set colorRgb or backgroundImageFile.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function Delete-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Permanently deletes a shared drive for which the user is an organizer.
The shared drive cannot contain any untrashed items.

.PARAMETER DriveId
The ID of the shared drive



#>
}


Function Get-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId              = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a shared drive's metadata by ID.

.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function Hide-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId              = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "hide"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Hides a shared drive from the default view.

.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function List-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Q                    = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the user's shared drives.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Q
Query string for searching shared drives.
See the https://developers.google.com/drive/api/v3/search-shareddrives for supported syntax.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function Unhide-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DriveId              = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "unhide"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Restores a shared drive to the default view.

.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function Update-Drives {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ColorRgb,
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$ThemeId,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ColorRgb             = @{ OriginalName = '--colorRgb'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DriveId              = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                 = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThemeId              = @{ OriginalName = '--themeId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "drives"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates the metadate for a shared drive.

.PARAMETER ColorRgb
The color of this shared drive as an RGB hex string.
It can only be set on a drive.drives.update request that does not set themeId.	


.PARAMETER DriveId
The ID of the shared drive


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The name of this shared drive


.PARAMETER ThemeId
The ID of the theme from which the background image and color will be set.
The set of possible driveThemes can be retrieved from a drive.about.get response.
When not specified on a drive.drives.create request, a random theme is chosen from which the background image and color are set.
This is a write-only field; it can only be set on requests that don't set colorRgb or backgroundImageFile.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator



#>
}


Function Delete-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$SendUpdates
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId  = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId     = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendUpdates = @{ OriginalName = '--sendUpdates'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes an event.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER EventId
Event identifier.


.PARAMETER SendUpdates
Guests who should receive notifications about the event update (for example, title changes, etc.).
[all|externalOnly|none]
all           - Notifications are sent to all guests.
externalOnly  - Notifications are sent to non-Google Calendar guests only.
none          - No notifications are sent. This value should only be used for migration use cases (note that in most migration cases the import method should be used).



#>
}


Function Get-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MaxAttendees,
        [Parameter()]
        [string]$TimeZone
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId   = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId      = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxAttendees = @{ OriginalName = '--maxAttendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone     = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns an event.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER EventId
Event identifier.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MaxAttendees
The maximum number of attendees to include in the response.
If there are more than the specified number of attendees, only the participant is returned.


.PARAMETER TimeZone
Time zone used in the response. Optional.
The default is the time zone of the calendar.



#>
}


Function Import-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$ConferenceDataVersion,
        [Parameter()]
        [string]$Destination,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$SupportsAttachments
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId            = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ConferenceDataVersion = @{ OriginalName = '--conferenceDataVersion'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Destination           = @{ OriginalName = '--destination'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId               = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SupportsAttachments   = @{ OriginalName = '--supportsAttachments'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "import"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Imports an event.
This operation is used to add a private copy of an existing event to a calendar.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER ConferenceDataVersion
Version number of conference data supported by the API client.
Version 0 assumes no conference data support and ignores conference data in the event's body.
Version 1 enables support for copying of ConferenceData as well as for creating new conferences using the createRequest field of conferenceData.


.PARAMETER Destination
Calendar identifier of the target calendar.


.PARAMETER EventId
Event identifier.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SupportsAttachments
Whether API client performing operation supports event attachments.



#>
}


Function Insert-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AddConferenceData,
        [Parameter()]
        [switch]$AnyoneCanAddSelf,
        [Parameter()]
        [string]$Attendees,
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$ColorId,
        [Parameter()]
        [string]$ConferenceDataVersion,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$EndDate,
        [Parameter()]
        [string]$EndDateTime,
        [Parameter()]
        [string]$EndTimeZone,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileUrl,
        [Parameter()]
        [switch]$GuestsCanInviteOthers,
        [Parameter()]
        [switch]$GuestsCanModify,
        [Parameter()]
        [switch]$GuestsCanSeeOtherGuests,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$Location,
        [Parameter()]
        [string]$MaxAttendees,
        [Parameter()]
        [string]$PrivateExtendedProperty,
        [Parameter()]
        [string]$Recurrence,
        [Parameter()]
        [string]$ReminderOverride,
        [Parameter()]
        [string]$SendUpdates,
        [Parameter()]
        [string]$Sequence,
        [Parameter()]
        [string]$SharedExtendedProperty,
        [Parameter()]
        [string]$StartDate,
        [Parameter()]
        [string]$StartDateTime,
        [Parameter()]
        [string]$StartTimeZone,
        [Parameter()]
        [string]$Status,
        [Parameter()]
        [string]$Summary,
        [Parameter()]
        [switch]$SupportsAttachments,
        [Parameter()]
        [string]$Transparency,
        [Parameter()]
        [switch]$UseDefaultReminders,
        [Parameter()]
        [string]$Visibility
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddConferenceData       = @{ OriginalName = '--addConferenceData'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            AnyoneCanAddSelf        = @{ OriginalName = '--anyoneCanAddSelf'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Attendees               = @{ OriginalName = '--attendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CalendarId              = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorId                 = @{ OriginalName = '--colorId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ConferenceDataVersion   = @{ OriginalName = '--conferenceDataVersion'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description             = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndDate                 = @{ OriginalName = '--endDate'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndDateTime             = @{ OriginalName = '--endDateTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndTimeZone             = @{ OriginalName = '--endTimeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileUrl                 = @{ OriginalName = '--fileUrl'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GuestsCanInviteOthers   = @{ OriginalName = '--guestsCanInviteOthers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            GuestsCanModify         = @{ OriginalName = '--guestsCanModify'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            GuestsCanSeeOtherGuests = @{ OriginalName = '--guestsCanSeeOtherGuests'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Id                      = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Location                = @{ OriginalName = '--location'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxAttendees            = @{ OriginalName = '--maxAttendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrivateExtendedProperty = @{ OriginalName = '--privateExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Recurrence              = @{ OriginalName = '--recurrence'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReminderOverride        = @{ OriginalName = '--reminderOverride'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendUpdates             = @{ OriginalName = '--sendUpdates'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sequence                = @{ OriginalName = '--sequence'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SharedExtendedProperty  = @{ OriginalName = '--sharedExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartDate               = @{ OriginalName = '--startDate'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartDateTime           = @{ OriginalName = '--startDateTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartTimeZone           = @{ OriginalName = '--startTimeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Status                  = @{ OriginalName = '--status'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Summary                 = @{ OriginalName = '--summary'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SupportsAttachments     = @{ OriginalName = '--supportsAttachments'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Transparency            = @{ OriginalName = '--transparency'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDefaultReminders     = @{ OriginalName = '--useDefaultReminders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Visibility              = @{ OriginalName = '--visibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates an event.

.PARAMETER AddConferenceData
Whether to add a Meet conference to the event.


.PARAMETER AnyoneCanAddSelf
Whether anyone can invite themselves to the event (currently works for Google+ events only).


.PARAMETER Attendees
Must be given in the following format: "--attendees "email=some.address@domain.com;resource=[true|false];optional=[true|false];responseStatus=accepted""
Can be used multiple times to invite more than one attendee.
If you batchPatch an event, rememder to specify ALL attendees (not just new ones)!


.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER ColorId
The color of the event.
This is an ID referring to an entry in the event section of the colors definition (see the colors endpoint).


.PARAMETER ConferenceDataVersion
Version number of conference data supported by the API client.
Version 0 assumes no conference data support and ignores conference data in the event's body.
Version 1 enables support for copying of ConferenceData as well as for creating new conferences using the createRequest field of conferenceData.


.PARAMETER Description
Description of the event. Can contain HTML.


.PARAMETER EndDate
The date, in the format "yyyy-mm-dd", if this is an all-day event.


.PARAMETER EndDateTime
The time, as a combined date-time value (formatted according to RFC3339).
A time zone offset is required unless a time zone is explicitly specified in timeZone.


.PARAMETER EndTimeZone
The time zone in which the time is specified.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich".)
For recurring events this field is required and specifies the time zone in which the recurrence is expanded.
For single events this field is optional and indicates a custom time zone for the event start/end.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileUrl
URL link to the attachment.
For adding Google Drive file attachments use the same format as in alternateLink property of the Files resource in the Drive API.
Can be used multiple times to add more than one file.


.PARAMETER GuestsCanInviteOthers
Whether attendees other than the organizer can invite others to the event.


.PARAMETER GuestsCanModify
Whether attendees other than the organizer can modify the event.


.PARAMETER GuestsCanSeeOtherGuests
Whether attendees other than the organizer can see who the event's attendees are.


.PARAMETER Id
Opaque identifier of the event. When creating new single or recurring events, you can specify their IDs.
Provided IDs must follow these rules:
characters allowed in the ID are those used in base32hex encoding, i.e. lowercase letters a-v and digits 0-9, see section 3.1.2 in RFC2938
the length of the ID must be between 5 and 1024 characters
the ID must be unique per calendar
Due to the globally distributed nature of the system, we cannot guarantee that ID collisions will be detected at event creation time.
To minimize the risk of collisions we recommend using an established UUID algorithm such as one described in RFC4122.
If you do not specify an ID, it will be automatically generated by the server.

Note that the icalUID and the id are not identical and only one of them should be supplied at event creation time.
One difference in their semantics is that in recurring events, all occurrences of one event have different ids while they all share the same icalUIDs.


.PARAMETER Location
Geographic location of the event as free-form text.


.PARAMETER MaxAttendees
The maximum number of attendees to include in the response.
If there are more than the specified number of attendees, only the participant is returned.


.PARAMETER PrivateExtendedProperty
Properties that are private to the copy of the event that appears on this calendar.


.PARAMETER Recurrence
List of RRULE, EXRULE, RDATE and EXDATE lines for a recurring event, as specified in RFC5545.
Note that DTSTART and DTEND lines are not allowed in this field; event start and end times are specified in the start and end fields.
This field is omitted for single events or instances of recurring events.


.PARAMETER ReminderOverride
If the event doesn't use the default reminders, this lists the reminders specific to the event, or, if not set, indicates that no reminders are set for this event.
The maximum number of override reminders is 5.
Must be specified in the following format: "--reminderOverride "method=[email|popup];minutes=[0-40320]""
Can be used multiple times to specify more than one reminder override.


.PARAMETER SendUpdates
Guests who should receive notifications about the event update (for example, title changes, etc.).
[all|externalOnly|none]
all           - Notifications are sent to all guests.
externalOnly  - Notifications are sent to non-Google Calendar guests only.
none          - No notifications are sent. This value should only be used for migration use cases (note that in most migration cases the import method should be used).


.PARAMETER Sequence
Sequence number as per iCalendar.


.PARAMETER SharedExtendedProperty
Properties that are shared between copies of the event on other attendees' calendars.


.PARAMETER StartDate
The date, in the format "yyyy-mm-dd", if this is an all-day event.


.PARAMETER StartDateTime
The time, as a combined date-time value (formatted according to RFC3339).
A time zone offset is required unless a time zone is explicitly specified in timeZone.


.PARAMETER StartTimeZone
The time zone in which the time is specified.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich".)
For recurring events this field is required and specifies the time zone in which the recurrence is expanded.
For single events this field is optional and indicates a custom time zone for the event start/end.


.PARAMETER Status
Status of the event.
[confirmed|tentative|cancelled]
confirmed  - The event is confirmed. This is the default status.
tentative  - The event is tentatively confirmed.
cancelled  - The event is cancelled (deleted). The list method returns cancelled events only on incremental sync (when syncToken or updatedMin are specified) or if the showDeleted flag is set to true. The get method always returns them.
A cancelled status represents two different states depending on the event type:

Cancelled exceptions of an uncancelled recurring event indicate that this instance should no longer be presented to the user. Clients should store these events for the lifetime of the parent recurring event.
Cancelled exceptions are only guaranteed to have values for the id, recurringEventId and originalStartTime fields populated. The other fields might be empty.

All other cancelled events represent deleted events. Clients should remove their locally synced copies. Such cancelled events will eventually disappear, so do not rely on them being available indefinitely.
Deleted events are only guaranteed to have the id field populated.

On the organizer's calendar, cancelled events continue to expose event details (summary, location, etc.) so that they can be restored (undeleted). Similarly, the events to which the user was invited and that they manually removed continue to provide details. However, incremental sync requests with showDeleted set to false will not return these details.
If an event changes its organizer (for example via the move operation) and the original organizer is not on the attendee list, it will leave behind a cancelled event where only the id field is guaranteed to be populated.


.PARAMETER Summary
Title of the event.


.PARAMETER SupportsAttachments
Whether API client performing operation supports event attachments.


.PARAMETER Transparency
Whether the event blocks time on the calendar.
[opaque|transparent]
opaque       - Default value. The event does block time on the calendar. This is equivalent to setting Show me as to Busy in the Calendar UI.
transparent  - The event does not block time on the calendar. This is equivalent to setting Show me as to Available in the Calendar UI.


.PARAMETER UseDefaultReminders
Whether the default reminders of the calendar apply to the event.


.PARAMETER Visibility
Visibility of the event.
[default|public|private|confidential]
default       - Uses the default visibility for events on the calendar. This is the default value.
public        - The event is public and event details are visible to all readers of the calendar.
private       - The event is private and only event attendees may view event details.
confidential  - The event is private. This value is provided for compatibility reasons.



#>
}


Function Instances-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MaxAttendees,
        [Parameter()]
        [string]$OriginalStart,
        [Parameter()]
        [switch]$ShowDeleted,
        [Parameter()]
        [string]$TimeMax,
        [Parameter()]
        [string]$TimeMin,
        [Parameter()]
        [string]$TimeZone
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId    = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId       = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxAttendees  = @{ OriginalName = '--maxAttendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OriginalStart = @{ OriginalName = '--originalStart'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ShowDeleted   = @{ OriginalName = '--showDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            TimeMax       = @{ OriginalName = '--timeMax'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeMin       = @{ OriginalName = '--timeMin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone      = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "instances"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns instances of the specified recurring event.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER EventId
Event identifier.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MaxAttendees
The maximum number of attendees to include in the response.
If there are more than the specified number of attendees, only the participant is returned.


.PARAMETER OriginalStart
The original start time of the instance in the result.


.PARAMETER ShowDeleted
Whether to include deleted events (with status equals "cancelled") in the result.
Cancelled instances of recurring events (but not the underlying recurring event) will still be included if showDeleted and singleEvents are both False.
If showDeleted and singleEvents are both True, only single instances of deleted events (but not the underlying recurring events) are returned.


.PARAMETER TimeMax
Upper bound (exclusive) for an event's start time to filter by.
Must be an RFC3339 timestamp with mandatory time zone offset, for example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z.
Milliseconds may be provided but are ignored. If timeMin is set, timeMax must be greater than timeMin.


.PARAMETER TimeMin
Lower bound (exclusive) for an event's end time to filter by.
Must be an RFC3339 timestamp with mandatory time zone offset, for example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z.
Milliseconds may be provided but are ignored. If timeMax is set, timeMin must be smaller than timeMax.


.PARAMETER TimeZone
Time zone used in the response. Optional.
The default is the time zone of the calendar.



#>
}


Function List-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ICalUID,
        [Parameter()]
        [string]$MaxAttendees,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$PrivateExtendedProperty,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [string]$SharedExtendedProperty,
        [Parameter()]
        [switch]$ShowDeleted,
        [Parameter()]
        [switch]$ShowHiddenInvitations,
        [Parameter()]
        [switch]$SingleEvents,
        [Parameter()]
        [string]$TimeMax,
        [Parameter()]
        [string]$TimeMin,
        [Parameter()]
        [string]$TimeZone,
        [Parameter()]
        [string]$UpdatedMin
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId              = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ICalUID                 = @{ OriginalName = '--iCalUID'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxAttendees            = @{ OriginalName = '--maxAttendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy                 = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrivateExtendedProperty = @{ OriginalName = '--privateExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Q                       = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SharedExtendedProperty  = @{ OriginalName = '--sharedExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ShowDeleted             = @{ OriginalName = '--showDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ShowHiddenInvitations   = @{ OriginalName = '--showHiddenInvitations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            SingleEvents            = @{ OriginalName = '--singleEvents'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            TimeMax                 = @{ OriginalName = '--timeMax'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeMin                 = @{ OriginalName = '--timeMin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone                = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UpdatedMin              = @{ OriginalName = '--updatedMin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns events on the specified calendar.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ICalUID
ICalUID sets the optional parameter "iCalUID": Specifies event ID in the iCalendar format to be included in the response.


.PARAMETER MaxAttendees
The maximum number of attendees to include in the response.
If there are more than the specified number of attendees, only the participant is returned.


.PARAMETER OrderBy
The order of the events returned in the result. Optional. The default is an unspecified, stable order.
Acceptable values are:
startTime  - Order by the start date/time (ascending). This is only available when querying single events (i.e. the parameter singleEvents is True)
updated    - Order by last modification time (ascending).


.PARAMETER PrivateExtendedProperty
Properties that are private to the copy of the event that appears on this calendar.


.PARAMETER Q
Free text search terms to find events that match these terms in any field, except for extended properties.


.PARAMETER SharedExtendedProperty
Properties that are shared between copies of the event on other attendees' calendars.


.PARAMETER ShowDeleted
Whether to include deleted events (with status equals "cancelled") in the result.
Cancelled instances of recurring events (but not the underlying recurring event) will still be included if showDeleted and singleEvents are both False.
If showDeleted and singleEvents are both True, only single instances of deleted events (but not the underlying recurring events) are returned.


.PARAMETER ShowHiddenInvitations
Whether to include hidden invitations in the result.


.PARAMETER SingleEvents
Whether to expand recurring events into instances and only return single one-off events and instances of recurring events, but not the underlying recurring events themselves.


.PARAMETER TimeMax
Upper bound (exclusive) for an event's start time to filter by.
Must be an RFC3339 timestamp with mandatory time zone offset, for example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z.
Milliseconds may be provided but are ignored. If timeMin is set, timeMax must be greater than timeMin.


.PARAMETER TimeMin
Lower bound (exclusive) for an event's end time to filter by.
Must be an RFC3339 timestamp with mandatory time zone offset, for example, 2011-06-03T10:00:00-07:00, 2011-06-03T10:00:00Z.
Milliseconds may be provided but are ignored. If timeMax is set, timeMin must be smaller than timeMax.


.PARAMETER TimeZone
Time zone used in the response. Optional.
The default is the time zone of the calendar.


.PARAMETER UpdatedMin
Lower bound for an event's last modification time (as a RFC3339 timestamp) to filter by.
When specified, entries deleted since this time will always be included regardless of showDeleted.



#>
}


Function Move-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Destination,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SendUpdates
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId  = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Destination = @{ OriginalName = '--destination'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId     = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendUpdates = @{ OriginalName = '--sendUpdates'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "move"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Moves an event to another calendar, i.e. changes an event's organizer.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Destination
Calendar identifier of the target calendar.


.PARAMETER EventId
Event identifier.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SendUpdates
Guests who should receive notifications about the event update (for example, title changes, etc.).
[all|externalOnly|none]
all           - Notifications are sent to all guests.
externalOnly  - Notifications are sent to non-Google Calendar guests only.
none          - No notifications are sent. This value should only be used for migration use cases (note that in most migration cases the import method should be used).



#>
}


Function Patch-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AddConferenceData,
        [Parameter()]
        [switch]$AnyoneCanAddSelf,
        [Parameter()]
        [string]$Attendees,
        [Parameter()]
        [switch]$AttendeesOmitted,
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$ColorId,
        [Parameter()]
        [string]$ConferenceDataVersion,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$EndDate,
        [Parameter()]
        [string]$EndDateTime,
        [Parameter()]
        [string]$EndTimeZone,
        [Parameter()]
        [string]$EventId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileUrl,
        [Parameter()]
        [switch]$GuestsCanInviteOthers,
        [Parameter()]
        [switch]$GuestsCanModify,
        [Parameter()]
        [switch]$GuestsCanSeeOtherGuests,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$Location,
        [Parameter()]
        [string]$MaxAttendees,
        [Parameter()]
        [string]$PrivateExtendedProperty,
        [Parameter()]
        [string]$Recurrence,
        [Parameter()]
        [string]$ReminderOverride,
        [Parameter()]
        [string]$SendUpdates,
        [Parameter()]
        [string]$Sequence,
        [Parameter()]
        [string]$SharedExtendedProperty,
        [Parameter()]
        [string]$StartDate,
        [Parameter()]
        [string]$StartDateTime,
        [Parameter()]
        [string]$StartTimeZone,
        [Parameter()]
        [string]$Status,
        [Parameter()]
        [string]$Summary,
        [Parameter()]
        [switch]$SupportsAttachments,
        [Parameter()]
        [string]$Transparency,
        [Parameter()]
        [switch]$UseDefaultReminders,
        [Parameter()]
        [string]$Visibility
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddConferenceData       = @{ OriginalName = '--addConferenceData'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            AnyoneCanAddSelf        = @{ OriginalName = '--anyoneCanAddSelf'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Attendees               = @{ OriginalName = '--attendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AttendeesOmitted        = @{ OriginalName = '--attendeesOmitted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CalendarId              = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ColorId                 = @{ OriginalName = '--colorId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ConferenceDataVersion   = @{ OriginalName = '--conferenceDataVersion'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description             = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndDate                 = @{ OriginalName = '--endDate'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndDateTime             = @{ OriginalName = '--endDateTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EndTimeZone             = @{ OriginalName = '--endTimeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EventId                 = @{ OriginalName = '--eventId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileUrl                 = @{ OriginalName = '--fileUrl'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GuestsCanInviteOthers   = @{ OriginalName = '--guestsCanInviteOthers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            GuestsCanModify         = @{ OriginalName = '--guestsCanModify'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            GuestsCanSeeOtherGuests = @{ OriginalName = '--guestsCanSeeOtherGuests'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Id                      = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Location                = @{ OriginalName = '--location'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxAttendees            = @{ OriginalName = '--maxAttendees'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrivateExtendedProperty = @{ OriginalName = '--privateExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Recurrence              = @{ OriginalName = '--recurrence'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReminderOverride        = @{ OriginalName = '--reminderOverride'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendUpdates             = @{ OriginalName = '--sendUpdates'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sequence                = @{ OriginalName = '--sequence'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SharedExtendedProperty  = @{ OriginalName = '--sharedExtendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartDate               = @{ OriginalName = '--startDate'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartDateTime           = @{ OriginalName = '--startDateTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartTimeZone           = @{ OriginalName = '--startTimeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Status                  = @{ OriginalName = '--status'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Summary                 = @{ OriginalName = '--summary'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SupportsAttachments     = @{ OriginalName = '--supportsAttachments'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Transparency            = @{ OriginalName = '--transparency'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDefaultReminders     = @{ OriginalName = '--useDefaultReminders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Visibility              = @{ OriginalName = '--visibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates an event. This method supports patch semantics.

.PARAMETER AddConferenceData
Whether to add a Meet conference to the event.


.PARAMETER AnyoneCanAddSelf
Whether anyone can invite themselves to the event (currently works for Google+ events only).


.PARAMETER Attendees
Must be given in the following format: "--attendees "email=some.address@domain.com;resource=[true|false];optional=[true|false];responseStatus=accepted""
Can be used multiple times to invite more than one attendee.
If you batchPatch an event, rememder to specify ALL attendees (not just new ones)!


.PARAMETER AttendeesOmitted
Whether attendees may have been omitted from the event's representation.
When retrieving an event, this may be due to a restriction specified by the maxAttendee query parameter.
When updating an event, this can be used to only update the participant's response.


.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER ColorId
The color of the event.
This is an ID referring to an entry in the event section of the colors definition (see the colors endpoint).


.PARAMETER ConferenceDataVersion
Version number of conference data supported by the API client.
Version 0 assumes no conference data support and ignores conference data in the event's body.
Version 1 enables support for copying of ConferenceData as well as for creating new conferences using the createRequest field of conferenceData.


.PARAMETER Description
Description of the event. Can contain HTML.


.PARAMETER EndDate
The date, in the format "yyyy-mm-dd", if this is an all-day event.


.PARAMETER EndDateTime
The time, as a combined date-time value (formatted according to RFC3339).
A time zone offset is required unless a time zone is explicitly specified in timeZone.


.PARAMETER EndTimeZone
The time zone in which the time is specified.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich".)
For recurring events this field is required and specifies the time zone in which the recurrence is expanded.
For single events this field is optional and indicates a custom time zone for the event start/end.


.PARAMETER EventId
Event identifier.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileUrl
URL link to the attachment.
For adding Google Drive file attachments use the same format as in alternateLink property of the Files resource in the Drive API.
Can be used multiple times to add more than one file.


.PARAMETER GuestsCanInviteOthers
Whether attendees other than the organizer can invite others to the event.


.PARAMETER GuestsCanModify
Whether attendees other than the organizer can modify the event.


.PARAMETER GuestsCanSeeOtherGuests
Whether attendees other than the organizer can see who the event's attendees are.


.PARAMETER Id
Opaque identifier of the event. When creating new single or recurring events, you can specify their IDs.
Provided IDs must follow these rules:
characters allowed in the ID are those used in base32hex encoding, i.e. lowercase letters a-v and digits 0-9, see section 3.1.2 in RFC2938
the length of the ID must be between 5 and 1024 characters
the ID must be unique per calendar
Due to the globally distributed nature of the system, we cannot guarantee that ID collisions will be detected at event creation time.
To minimize the risk of collisions we recommend using an established UUID algorithm such as one described in RFC4122.
If you do not specify an ID, it will be automatically generated by the server.

Note that the icalUID and the id are not identical and only one of them should be supplied at event creation time.
One difference in their semantics is that in recurring events, all occurrences of one event have different ids while they all share the same icalUIDs.


.PARAMETER Location
Geographic location of the event as free-form text.


.PARAMETER MaxAttendees
The maximum number of attendees to include in the response.
If there are more than the specified number of attendees, only the participant is returned.


.PARAMETER PrivateExtendedProperty
Properties that are private to the copy of the event that appears on this calendar.


.PARAMETER Recurrence
List of RRULE, EXRULE, RDATE and EXDATE lines for a recurring event, as specified in RFC5545.
Note that DTSTART and DTEND lines are not allowed in this field; event start and end times are specified in the start and end fields.
This field is omitted for single events or instances of recurring events.


.PARAMETER ReminderOverride
If the event doesn't use the default reminders, this lists the reminders specific to the event, or, if not set, indicates that no reminders are set for this event.
The maximum number of override reminders is 5.
Must be specified in the following format: "--reminderOverride "method=[email|popup];minutes=[0-40320]""
Can be used multiple times to specify more than one reminder override.


.PARAMETER SendUpdates
Guests who should receive notifications about the event update (for example, title changes, etc.).
[all|externalOnly|none]
all           - Notifications are sent to all guests.
externalOnly  - Notifications are sent to non-Google Calendar guests only.
none          - No notifications are sent. This value should only be used for migration use cases (note that in most migration cases the import method should be used).


.PARAMETER Sequence
Sequence number as per iCalendar.


.PARAMETER SharedExtendedProperty
Properties that are shared between copies of the event on other attendees' calendars.


.PARAMETER StartDate
The date, in the format "yyyy-mm-dd", if this is an all-day event.


.PARAMETER StartDateTime
The time, as a combined date-time value (formatted according to RFC3339).
A time zone offset is required unless a time zone is explicitly specified in timeZone.


.PARAMETER StartTimeZone
The time zone in which the time is specified.
(Formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich".)
For recurring events this field is required and specifies the time zone in which the recurrence is expanded.
For single events this field is optional and indicates a custom time zone for the event start/end.


.PARAMETER Status
Status of the event.
[confirmed|tentative|cancelled]
confirmed  - The event is confirmed. This is the default status.
tentative  - The event is tentatively confirmed.
cancelled  - The event is cancelled (deleted). The list method returns cancelled events only on incremental sync (when syncToken or updatedMin are specified) or if the showDeleted flag is set to true. The get method always returns them.
A cancelled status represents two different states depending on the event type:

Cancelled exceptions of an uncancelled recurring event indicate that this instance should no longer be presented to the user. Clients should store these events for the lifetime of the parent recurring event.
Cancelled exceptions are only guaranteed to have values for the id, recurringEventId and originalStartTime fields populated. The other fields might be empty.

All other cancelled events represent deleted events. Clients should remove their locally synced copies. Such cancelled events will eventually disappear, so do not rely on them being available indefinitely.
Deleted events are only guaranteed to have the id field populated.

On the organizer's calendar, cancelled events continue to expose event details (summary, location, etc.) so that they can be restored (undeleted). Similarly, the events to which the user was invited and that they manually removed continue to provide details. However, incremental sync requests with showDeleted set to false will not return these details.
If an event changes its organizer (for example via the move operation) and the original organizer is not on the attendee list, it will leave behind a cancelled event where only the id field is guaranteed to be populated.


.PARAMETER Summary
Title of the event.


.PARAMETER SupportsAttachments
Whether API client performing operation supports event attachments.


.PARAMETER Transparency
Whether the event blocks time on the calendar.
[opaque|transparent]
opaque       - Default value. The event does block time on the calendar. This is equivalent to setting Show me as to Busy in the Calendar UI.
transparent  - The event does not block time on the calendar. This is equivalent to setting Show me as to Available in the Calendar UI.


.PARAMETER UseDefaultReminders
Whether the default reminders of the calendar apply to the event.


.PARAMETER Visibility
Visibility of the event.
[default|public|private|confidential]
default       - Uses the default visibility for events on the calendar. This is the default value.
public        - The event is public and event details are visible to all readers of the calendar.
private       - The event is private and only event attendees may view event details.
confidential  - The event is private. This value is provided for compatibility reasons.



#>
}


Function QuickAdd-Events {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SendUpdates,
        [Parameter()]
        [string]$Text
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarId  = @{ OriginalName = '--calendarId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendUpdates = @{ OriginalName = '--sendUpdates'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Text        = @{ OriginalName = '--text'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "events"
            "quickAdd"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates an event based on a simple text string.

.PARAMETER CalendarId
Calendar identifier. To retrieve calendar IDs call the calendarList.list method.
If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SendUpdates
Guests who should receive notifications about the event update (for example, title changes, etc.).
[all|externalOnly|none]
all           - Notifications are sent to all guests.
externalOnly  - Notifications are sent to non-Google Calendar guests only.
none          - No notifications are sent. This value should only be used for migration use cases (note that in most migration cases the import method should be used).


.PARAMETER Text
The text describing the event to be created.



#>
}


Function Copy-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AppProperties,
        [Parameter()]
        [switch]$CopyRequiresWriterPermission,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [switch]$IgnoreDefaultVisibility,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [switch]$KeepRevisionForever,
        [Parameter()]
        [string]$MimeType,
        [Parameter()]
        [string]$ModifiedTime,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$OcrLanguage,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Properties,
        [Parameter()]
        [switch]$ReadOnly,
        [Parameter()]
        [string]$ReadOnlyReason,
        [Parameter()]
        [switch]$Starred,
        [Parameter()]
        [string]$ThumbnailImage,
        [Parameter()]
        [string]$ThumbnailMimeType,
        [Parameter()]
        [string]$ViewedByMeTime,
        [Parameter()]
        [switch]$WritersCanShare
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AppProperties                = @{ OriginalName = '--appProperties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CopyRequiresWriterPermission = @{ OriginalName = '--copyRequiresWriterPermission'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Description                  = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                       = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id                           = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IgnoreDefaultVisibility      = @{ OriginalName = '--ignoreDefaultVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludePermissionsForView    = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            KeepRevisionForever          = @{ OriginalName = '--keepRevisionForever'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            MimeType                     = @{ OriginalName = '--mimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ModifiedTime                 = @{ OriginalName = '--modifiedTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                         = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OcrLanguage                  = @{ OriginalName = '--ocrLanguage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent                       = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Properties                   = @{ OriginalName = '--properties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadOnly                     = @{ OriginalName = '--readOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ReadOnlyReason               = @{ OriginalName = '--readOnlyReason'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Starred                      = @{ OriginalName = '--starred'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ThumbnailImage               = @{ OriginalName = '--thumbnailImage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThumbnailMimeType            = @{ OriginalName = '--thumbnailMimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ViewedByMeTime               = @{ OriginalName = '--viewedByMeTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WritersCanShare              = @{ OriginalName = '--writersCanShare'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "copy"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a copy of a file and applies any requested updates with patch semantics.
Use "files copy recursive" to copy folders.

.PARAMETER AppProperties
A collection of arbitrary key-value pairs which are private to the requesting app.
Entries with null values are cleared in update and copy requests.


.PARAMETER CopyRequiresWriterPermission
Whether the options to copy, print, or download this file, should be disabled for readers and commenters.


.PARAMETER Description
A short description of the file.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file


.PARAMETER Id
The ID of the file.


.PARAMETER IgnoreDefaultVisibility
Whether to ignore the domain's default visibility settings for the created file.
Domain administrators can choose to make all uploaded files visible to the domain by default;
this parameter bypasses that behavior for the request.
Permissions are still inherited from parent folders.


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER KeepRevisionForever
Whether to set the 'keepForever' field in the new head revision.
This is only applicable to files with binary content in Google Drive.
Only 200 revisions for the file can be kept forever.
If the limit is reached, try deleting pinned revisions.


.PARAMETER MimeType
The MIME type of the file.
Google Drive will attempt to automatically detect an appropriate value from uploaded content if no value is provided.
The value cannot be changed unless a new revision is uploaded.

If a file is created with a Google Doc MIME type, the uploaded content will be imported if possible.
The supported import formats are published in the About resource.


.PARAMETER ModifiedTime
The last time the file was modified by anyone (RFC 3339 date-time).
Note that setting modifiedTime will also update modifiedByMeTime for the user.


.PARAMETER Name
The name of the file. This is not necessarily unique within a folder.
Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.


.PARAMETER OcrLanguage
A language hint for OCR processing during image import (ISO 639-1 code).


.PARAMETER Parent
The single parent of the file.


.PARAMETER Properties
A collection of arbitrary key-value pairs which are visible to all apps.
Entries with null values are cleared in update and copy requests.


.PARAMETER ReadOnly
Whether the content of the file is read-only.
If a file is read-only, a new revision of the file may not be added, comments may not be added or modified, and the title of the file may not be modified.


.PARAMETER ReadOnlyReason
Reason for why the content of the file is restricted.
This is only mutable on requests that also set readOnly=true.


.PARAMETER Starred
Whether the user has starred the file.


.PARAMETER ThumbnailImage
The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).


.PARAMETER ThumbnailMimeType
The MIME type of the thumbnail.


.PARAMETER ViewedByMeTime
The last time the file was viewed by the user (RFC 3339 date-time).


.PARAMETER WritersCanShare
Whether users with only writer permission can modify the file's permissions.
Not populated for items in shared drives.



#>
}


Function Create-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AppProperties,
        [Parameter()]
        [switch]$CopyRequiresWriterPermission,
        [Parameter()]
        [string]$CreatedTime,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FolderColorRgb,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [switch]$IgnoreDefaultVisibility,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [string]$IndexableText,
        [Parameter()]
        [switch]$KeepRevisionForever,
        [Parameter()]
        [string]$LocalFilePath,
        [Parameter()]
        [string]$MimeType,
        [Parameter()]
        [string]$ModifiedTime,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$OcrLanguage,
        [Parameter()]
        [string]$OriginalFilename,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Properties,
        [Parameter()]
        [switch]$ReadOnly,
        [Parameter()]
        [string]$ReadOnlyReason,
        [Parameter()]
        [switch]$Starred,
        [Parameter()]
        [string]$TargetId,
        [Parameter()]
        [string]$ThumbnailImage,
        [Parameter()]
        [string]$ThumbnailMimeType,
        [Parameter()]
        [switch]$UseContentAsIndexableText,
        [Parameter()]
        [string]$ViewedByMeTime,
        [Parameter()]
        [switch]$WritersCanShare
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AppProperties                = @{ OriginalName = '--appProperties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CopyRequiresWriterPermission = @{ OriginalName = '--copyRequiresWriterPermission'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CreatedTime                  = @{ OriginalName = '--createdTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description                  = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FolderColorRgb               = @{ OriginalName = '--folderColorRgb'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id                           = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IgnoreDefaultVisibility      = @{ OriginalName = '--ignoreDefaultVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludePermissionsForView    = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IndexableText                = @{ OriginalName = '--indexableText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            KeepRevisionForever          = @{ OriginalName = '--keepRevisionForever'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            LocalFilePath                = @{ OriginalName = '--localFilePath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MimeType                     = @{ OriginalName = '--mimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ModifiedTime                 = @{ OriginalName = '--modifiedTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                         = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OcrLanguage                  = @{ OriginalName = '--ocrLanguage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OriginalFilename             = @{ OriginalName = '--originalFilename'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent                       = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Properties                   = @{ OriginalName = '--properties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadOnly                     = @{ OriginalName = '--readOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ReadOnlyReason               = @{ OriginalName = '--readOnlyReason'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Starred                      = @{ OriginalName = '--starred'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            TargetId                     = @{ OriginalName = '--targetId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThumbnailImage               = @{ OriginalName = '--thumbnailImage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThumbnailMimeType            = @{ OriginalName = '--thumbnailMimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseContentAsIndexableText    = @{ OriginalName = '--useContentAsIndexableText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ViewedByMeTime               = @{ OriginalName = '--viewedByMeTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WritersCanShare              = @{ OriginalName = '--writersCanShare'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new file or folder. Can also be used to upload files.

.PARAMETER AppProperties
A collection of arbitrary key-value pairs which are private to the requesting app.
Entries with null values are cleared in update and copy requests.


.PARAMETER CopyRequiresWriterPermission
Whether the options to copy, print, or download this file, should be disabled for readers and commenters.


.PARAMETER CreatedTime
The time at which the file was created (RFC 3339 date-time).


.PARAMETER Description
A short description of the file.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FolderColorRgb
The color for a folder as an RGB hex string.
The supported colors are published in the folderColorPalette field of the About resource.
If an unsupported color is specified, the closest color in the palette will be used instead.


.PARAMETER Id
The ID of the file.


.PARAMETER IgnoreDefaultVisibility
Whether to ignore the domain's default visibility settings for the created file.
Domain administrators can choose to make all uploaded files visible to the domain by default;
this parameter bypasses that behavior for the request.
Permissions are still inherited from parent folders.


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER IndexableText
Text to be indexed for the file to improve fullText queries.
This is limited to 128KB in length and may contain HTML elements.


.PARAMETER KeepRevisionForever
Whether to set the 'keepForever' field in the new head revision.
This is only applicable to files with binary content in Google Drive.
Only 200 revisions for the file can be kept forever.
If the limit is reached, try deleting pinned revisions.


.PARAMETER LocalFilePath
Whether the file has been trashed, either explicitly or from a trashed parent folder.
Only the owner may trash a file.
The trashed item is excluded from all files.list responses returned for any user who does not own the file.
However, all users with access to the file can see the trashed item metadata in an API response.
All users with access can copy, download, export, and share the file.


.PARAMETER MimeType
The MIME type of the file.
Google Drive will attempt to automatically detect an appropriate value from uploaded content if no value is provided.
The value cannot be changed unless a new revision is uploaded.

If a file is created with a Google Doc MIME type, the uploaded content will be imported if possible.
The supported import formats are published in the About resource.


.PARAMETER ModifiedTime
The last time the file was modified by anyone (RFC 3339 date-time).
Note that setting modifiedTime will also update modifiedByMeTime for the user.


.PARAMETER Name
The name of the file. This is not necessarily unique within a folder.
Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.


.PARAMETER OcrLanguage
A language hint for OCR processing during image import (ISO 639-1 code).


.PARAMETER OriginalFilename
The original filename of the uploaded content if available, or else the original value of the name field.
This is only available for files with binary content in Google Drive.


.PARAMETER Parent
The single parent of the file.


.PARAMETER Properties
A collection of arbitrary key-value pairs which are visible to all apps.
Entries with null values are cleared in update and copy requests.


.PARAMETER ReadOnly
Whether the content of the file is read-only.
If a file is read-only, a new revision of the file may not be added, comments may not be added or modified, and the title of the file may not be modified.


.PARAMETER ReadOnlyReason
Reason for why the content of the file is restricted.
This is only mutable on requests that also set readOnly=true.


.PARAMETER Starred
Whether the user has starred the file.


.PARAMETER TargetId
The ID of the file that this shortcut points to.


.PARAMETER ThumbnailImage
The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).


.PARAMETER ThumbnailMimeType
The MIME type of the thumbnail.


.PARAMETER UseContentAsIndexableText
Whether users with only writer permission can modify the file's permissions.
Not populated for items in shared drives.


.PARAMETER ViewedByMeTime
The last time the file was viewed by the user (RFC 3339 date-time).


.PARAMETER WritersCanShare
Whether users with only writer permission can modify the file's permissions.
Not populated for items in shared drives.



#>
}


Function Delete-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            FileId = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.

.PARAMETER FileId
The ID of the file



#>
}


Function Download-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AcknowledgeAbuse,
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AcknowledgeAbuse = @{ OriginalName = '--acknowledgeAbuse'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            FileId           = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "download"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Download a file

.PARAMETER AcknowledgeAbuse
Whether the user is acknowledging the risk of downloading known malware or other abusive files.


.PARAMETER FileId
The ID of the file



#>
}


Function Export-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$MimeType
    )

    BEGIN {
        $__PARAMETERMAP = @{
            FileId   = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MimeType = @{ OriginalName = '--mimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "export"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Exports a Google Doc to the requested MIME type and returns the exported content.

.PARAMETER FileId
The ID of the file


.PARAMETER MimeType
The MIME type of the file.
Google Drive will attempt to automatically detect an appropriate value from uploaded content if no value is provided.
The value cannot be changed unless a new revision is uploaded.

If a file is created with a Google Doc MIME type, the uploaded content will be imported if possible.
The supported import formats are published in the About resource.



#>
}


Function GenerateIds-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Count,
        [Parameter()]
        [string]$Space
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Count = @{ OriginalName = '--count'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Space = @{ OriginalName = '--space'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "generateIds"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Generates a set of file IDs which can be provided in create or copy requests.

.PARAMETER Count
The number of IDs to return. Acceptable values are 1 to 1000, inclusive. (Default: 10)


.PARAMETER Space
The space in which the IDs can be used to create new files.
Supported values are 'drive' and 'appDataFolder'.



#>
}


Function Get-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$IncludePermissionsForView
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields                    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludePermissionsForView = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a file or folder's metadata or content by ID.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.



#>
}


Function List-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Corpora,
        [Parameter()]
        [string]$DriveId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeItemsFromAllDrives,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [string]$Spaces
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Corpora                   = @{ OriginalName = '--corpora'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DriveId                   = @{ OriginalName = '--driveId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeItemsFromAllDrives = @{ OriginalName = '--includeItemsFromAllDrives'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludePermissionsForView = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy                   = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Q                         = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Spaces                    = @{ OriginalName = '--spaces'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists or searches files.

.PARAMETER Corpora
Groupings of files to which the query applies.
Supported groupings are:
'user' (files created by, opened by, or shared directly with the user)
'drive' (files in the specified shared drive as indicated by the 'driveId')
'domain' (files shared to the user's domain)
'allDrives' (A combination of 'user' and 'drive' for all drives where the user is a member).
When able, use 'user' or 'drive', instead of 'allDrives', for efficiency.


.PARAMETER DriveId
ID of the shared drive.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeItemsFromAllDrives
Whether both My Drive and shared drive items should be included in results.


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER OrderBy
A comma-separated list of sort keys.
Valid keys are 'createdTime', 'folder', 'modifiedByMeTime', 'modifiedTime', 'name', 'name_natural', 'quotaBytesUsed', 'recency', 'sharedWithMeTime', 'starred', and 'viewedByMeTime'.
Each key sorts ascending by default, but may be reversed with the 'desc' modifier.
Example usage: ?orderBy=folder,modifiedTime desc,name.
Please note that there is a current limitation for users with approximately one million files in which the requested sort order is ignored.


.PARAMETER Q
A query for filtering the file results.
See the https://developers.google.com/drive/api/v3/search-files for the supported syntax.


.PARAMETER Spaces
A comma-separated list of spaces to query within the corpus.
Supported values are 'drive', 'appDataFolder' and 'photos'.



#>
}


Function Move-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$Parent
    )

    BEGIN {
        $__PARAMETERMAP = @{
            FileId = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "move"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Move a file.

.PARAMETER FileId
The ID of the file


.PARAMETER Parent
The single parent of the file.



#>
}


Function Update-Files {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AppProperties,
        [Parameter()]
        [switch]$CopyRequiresWriterPermission,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$FolderColorRgb,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [string]$IndexableText,
        [Parameter()]
        [switch]$KeepRevisionForever,
        [Parameter()]
        [string]$LocalFilePath,
        [Parameter()]
        [string]$MimeType,
        [Parameter()]
        [string]$ModifiedTime,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$OcrLanguage,
        [Parameter()]
        [string]$OriginalFilename,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Properties,
        [Parameter()]
        [switch]$ReadOnly,
        [Parameter()]
        [string]$ReadOnlyReason,
        [Parameter()]
        [switch]$Starred,
        [Parameter()]
        [string]$ThumbnailImage,
        [Parameter()]
        [string]$ThumbnailMimeType,
        [Parameter()]
        [switch]$Trashed,
        [Parameter()]
        [switch]$UseContentAsIndexableText,
        [Parameter()]
        [string]$ViewedByMeTime,
        [Parameter()]
        [switch]$WritersCanShare
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AppProperties                = @{ OriginalName = '--appProperties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CopyRequiresWriterPermission = @{ OriginalName = '--copyRequiresWriterPermission'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Description                  = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                       = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FolderColorRgb               = @{ OriginalName = '--folderColorRgb'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludePermissionsForView    = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IndexableText                = @{ OriginalName = '--indexableText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            KeepRevisionForever          = @{ OriginalName = '--keepRevisionForever'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            LocalFilePath                = @{ OriginalName = '--localFilePath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MimeType                     = @{ OriginalName = '--mimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ModifiedTime                 = @{ OriginalName = '--modifiedTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                         = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OcrLanguage                  = @{ OriginalName = '--ocrLanguage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OriginalFilename             = @{ OriginalName = '--originalFilename'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent                       = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Properties                   = @{ OriginalName = '--properties'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadOnly                     = @{ OriginalName = '--readOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ReadOnlyReason               = @{ OriginalName = '--readOnlyReason'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Starred                      = @{ OriginalName = '--starred'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ThumbnailImage               = @{ OriginalName = '--thumbnailImage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ThumbnailMimeType            = @{ OriginalName = '--thumbnailMimeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Trashed                      = @{ OriginalName = '--trashed'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UseContentAsIndexableText    = @{ OriginalName = '--useContentAsIndexableText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ViewedByMeTime               = @{ OriginalName = '--viewedByMeTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WritersCanShare              = @{ OriginalName = '--writersCanShare'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "files"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a file's metadata and/or content. This method supports patch semantics.

.PARAMETER AppProperties
A collection of arbitrary key-value pairs which are private to the requesting app.
Entries with null values are cleared in update and copy requests.


.PARAMETER CopyRequiresWriterPermission
Whether the options to copy, print, or download this file, should be disabled for readers and commenters.


.PARAMETER Description
A short description of the file.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file


.PARAMETER FolderColorRgb
The color for a folder as an RGB hex string.
The supported colors are published in the folderColorPalette field of the About resource.
If an unsupported color is specified, the closest color in the palette will be used instead.


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER IndexableText
Text to be indexed for the file to improve fullText queries.
This is limited to 128KB in length and may contain HTML elements.


.PARAMETER KeepRevisionForever
Whether to set the 'keepForever' field in the new head revision.
This is only applicable to files with binary content in Google Drive.
Only 200 revisions for the file can be kept forever.
If the limit is reached, try deleting pinned revisions.


.PARAMETER LocalFilePath
Whether the file has been trashed, either explicitly or from a trashed parent folder.
Only the owner may trash a file.
The trashed item is excluded from all files.list responses returned for any user who does not own the file.
However, all users with access to the file can see the trashed item metadata in an API response.
All users with access can copy, download, export, and share the file.


.PARAMETER MimeType
The MIME type of the file.
Google Drive will attempt to automatically detect an appropriate value from uploaded content if no value is provided.
The value cannot be changed unless a new revision is uploaded.

If a file is created with a Google Doc MIME type, the uploaded content will be imported if possible.
The supported import formats are published in the About resource.


.PARAMETER ModifiedTime
The last time the file was modified by anyone (RFC 3339 date-time).
Note that setting modifiedTime will also update modifiedByMeTime for the user.


.PARAMETER Name
The name of the file. This is not necessarily unique within a folder.
Note that for immutable items such as the top level folders of shared drives, My Drive root folder, and Application Data folder the name is constant.


.PARAMETER OcrLanguage
A language hint for OCR processing during image import (ISO 639-1 code).


.PARAMETER OriginalFilename
The original filename of the uploaded content if available, or else the original value of the name field.
This is only available for files with binary content in Google Drive.


.PARAMETER Parent
The single parent of the file.


.PARAMETER Properties
A collection of arbitrary key-value pairs which are visible to all apps.
Entries with null values are cleared in update and copy requests.


.PARAMETER ReadOnly
Whether the content of the file is read-only.
If a file is read-only, a new revision of the file may not be added, comments may not be added or modified, and the title of the file may not be modified.


.PARAMETER ReadOnlyReason
Reason for why the content of the file is restricted.
This is only mutable on requests that also set readOnly=true.


.PARAMETER Starred
Whether the user has starred the file.


.PARAMETER ThumbnailImage
The thumbnail data encoded with URL-safe Base64 (RFC 4648 section 5).


.PARAMETER ThumbnailMimeType
The MIME type of the thumbnail.


.PARAMETER Trashed
Whether the file has been trashed, either explicitly or from a trashed parent folder.
Only the owner may trash a file.
The trashed item is excluded from all files.list responses returned for any user who does not own the file.
However, all users with access to the file can see the trashed item metadata in an API response.
All users with access can copy, download, export, and share the file.


.PARAMETER UseContentAsIndexableText
Whether users with only writer permission can modify the file's permissions.
Not populated for items in shared drives.


.PARAMETER ViewedByMeTime
The last time the file was viewed by the user (RFC 3339 date-time).


.PARAMETER WritersCanShare
Whether users with only writer permission can modify the file's permissions.
Not populated for items in shared drives.



#>
}


Function Create-Filters {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddLabelIds,
        [Parameter()]
        [switch]$ExcludeChats,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Forward,
        [Parameter()]
        [string]$From,
        [Parameter()]
        [switch]$HasAttachment,
        [Parameter()]
        [string]$NegatedQuery,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$RemoveLabelIds,
        [Parameter()]
        [string]$Size,
        [Parameter()]
        [string]$SizeComparison,
        [Parameter()]
        [string]$Subject,
        [Parameter()]
        [string]$To,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddLabelIds    = @{ OriginalName = '--addLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExcludeChats   = @{ OriginalName = '--excludeChats'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Forward        = @{ OriginalName = '--forward'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            From           = @{ OriginalName = '--from'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HasAttachment  = @{ OriginalName = '--hasAttachment'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            NegatedQuery   = @{ OriginalName = '--negatedQuery'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query          = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RemoveLabelIds = @{ OriginalName = '--removeLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Size           = @{ OriginalName = '--size'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SizeComparison = @{ OriginalName = '--sizeComparison'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Subject        = @{ OriginalName = '--subject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            To             = @{ OriginalName = '--to'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "filters"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a filter.

.PARAMETER AddLabelIds
A list of IDs of labels to add to this message. Can be used multiple times.


.PARAMETER ExcludeChats
Whether the response should exclude chats.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Forward
Email address that the message should be forwarded to.


.PARAMETER From
The sender's display name or email address.


.PARAMETER HasAttachment
Whether the message has any attachment.


.PARAMETER NegatedQuery
Only return messages not matching the specified query.
Supports the same query format as the Gmail search box.
For example, "from:someuser@example.com rfc822msgid:<somemsgid@example.com> is:unread".


.PARAMETER Query
Only return messages matching the specified query.
Supports the same query format as the Gmail search box.
For example, "from:someuser@example.com rfc822msgid:<somemsgid@example.com> is:unread".


.PARAMETER RemoveLabelIds
A list of IDs of labels to remove from this message. Can be used multiple times.


.PARAMETER Size
The size of the entire RFC822 message in bytes, including all headers and attachments.


.PARAMETER SizeComparison
How the message size in bytes should be in relation to the size field.
"[SMALLER|LARGER]
SMALLER  - Find messages smaller than the given size.
LARGER   - Find messages larger than the given size.


.PARAMETER Subject
Case-insensitive phrase found in the message's subject. Trailing and leading whitespace are be trimmed and adjacent spaces are collapsed.


.PARAMETER To
The recipient's display name or email address. Includes recipients in the "to", "cc", and "bcc" header fields.
You can use simply the local part of the email address
For example, "example" and "example@" both match "example@gmail.com".
This field is case-insensitive.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-Filters {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "filters"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a filter.

.PARAMETER Id
The ID of the filter.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Get-Filters {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "filters"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a filter.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the filter.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function List-Filters {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "filters"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the message filters of a Gmail user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Create-ForwardingAddresses {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ForwardingEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ForwardingEmail = @{ OriginalName = '--forwardingEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "forwardingAddresses"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a forwarding address.
If ownership verification is required, a message will be sent to the recipient and the resource's verification status will be set to pending;
otherwise, the resource will be created with verification status set to accepted.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ForwardingEmail
An email address to which messages can be forwarded.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-ForwardingAddresses {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ForwardingEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ForwardingEmail = @{ OriginalName = '--forwardingEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "forwardingAddresses"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes the specified forwarding address and revokes any verification that may have been required.

.PARAMETER ForwardingEmail
An email address to which messages can be forwarded.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Get-ForwardingAddresses {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ForwardingEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ForwardingEmail = @{ OriginalName = '--forwardingEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "forwardingAddresses"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified forwarding address.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ForwardingEmail
An email address to which messages can be forwarded.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function List-ForwardingAddresses {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "forwardingAddresses"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the forwarding addresses for the specified account.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Query-FreeBusy {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarExpansionMax,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupExpansionMax,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$TimeMax,
        [Parameter()]
        [string]$TimeMin,
        [Parameter()]
        [string]$TimeZone
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarExpansionMax = @{ OriginalName = '--calendarExpansionMax'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupExpansionMax    = @{ OriginalName = '--groupExpansionMax'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id                   = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeMax              = @{ OriginalName = '--timeMax'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeMin              = @{ OriginalName = '--timeMin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TimeZone             = @{ OriginalName = '--timeZone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "freeBusy"
            "query"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns free/busy information for a set of calendars.

.PARAMETER CalendarExpansionMax
Maximal number of calendars for which FreeBusy information is to be provided.
Optional. Maximum value is 50.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupExpansionMax
Maximal number of calendar identifiers to be provided for a single group.
Optional. An error is returned for a group with more members than this value. Maximum value is 100.


.PARAMETER Id
The identifier of a calendar or a group.


.PARAMETER TimeMax
The end of the interval for the query formatted as per RFC3339.


.PARAMETER TimeMin
The start of the interval for the query formatted as per RFC3339.


.PARAMETER TimeZone
Time zone used in the response.
Optional. The default is UTC.



#>
}


Function GetAutoForwarding-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "getAutoForwarding"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the auto-forwarding setting for the specified account.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function GetImap-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "getImap"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets IMAP settings.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function GetLanguage-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "getLanguage"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets language settings.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function GetPop-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "getPop"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets POP settings.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function GetVacation-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "getVacation"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets vacation responder settings.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function UpdateAutoForwarding-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AutoExpunge,
        [Parameter()]
        [string]$Disposition,
        [Parameter()]
        [string]$EmailAddress,
        [Parameter()]
        [switch]$Enabled,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AutoExpunge  = @{ OriginalName = '--autoExpunge'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Disposition  = @{ OriginalName = '--disposition'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailAddress = @{ OriginalName = '--emailAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Enabled      = @{ OriginalName = '--enabled'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId       = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "updateAutoForwarding"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates the auto-forwarding setting for the specified account.
A verified forwarding address must be specified when auto-forwarding is enabled.

.PARAMETER AutoExpunge
If this value is true, Gmail will immediately expunge a message when it is marked as deleted in IMAP.
Otherwise, Gmail will wait for an update from the client before expunging messages marked as deleted.


.PARAMETER Disposition
The state that a message should be left in after it has been forwarded.
[LEAVE_IN_INBOX|ARCHIVE|TRASH|MARK_READ]
LEAVE_IN_INBOX  - Leave the message in the INBOX.
ARCHIVE         - Archive the message.
TRASH           - Move the message to the TRASH.
MARK_READ       - Leave the message in the INBOX and mark it as read.


.PARAMETER EmailAddress
Email address to which all incoming messages are forwarded.
This email address must be a verified member of the forwarding addresses.


.PARAMETER Enabled
Whether the setting is enabled


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function UpdateImap-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AutoExpunge,
        [Parameter()]
        [switch]$Enabled,
        [Parameter()]
        [string]$ExpungeBehavior,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MaxFolderSize,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AutoExpunge     = @{ OriginalName = '--autoExpunge'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Enabled         = @{ OriginalName = '--enabled'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ExpungeBehavior = @{ OriginalName = '--expungeBehavior'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MaxFolderSize   = @{ OriginalName = '--maxFolderSize'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "updateImap"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates IMAP settings.

.PARAMETER AutoExpunge
If this value is true, Gmail will immediately expunge a message when it is marked as deleted in IMAP.
Otherwise, Gmail will wait for an update from the client before expunging messages marked as deleted.


.PARAMETER Enabled
Whether the setting is enabled


.PARAMETER ExpungeBehavior
The action that will be executed on a message when it is marked as deleted and expunged from the last visible IMAP folder.
[ARCHIVE|TRASH|DELETE_FOREVER]
ARCHIVE - Archive messages marked as deleted.
TRASH - Move messages marked as deleted to the trash.
DELETE_FOREVER - Immediately and permanently delete messages marked as deleted. The expunged messages cannot be recovered.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MaxFolderSize
An optional limit on the number of messages that an IMAP folder may contain.
Legal values are 0, 1000, 2000, 5000 or 10000. A value of zero is interpreted to mean that there is no limit.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function UpdateLanguage-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DisplayLanguage,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DisplayLanguage = @{ OriginalName = '--displayLanguage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "updateLanguage"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates language settings.

.PARAMETER DisplayLanguage
The language to display Gmail in, formatted as an RFC 3066 Language Tag (for example en-GB, fr or ja for British English, French, or Japanese respectively).

The set of languages supported by Gmail evolves over time, so please refer to the "Language" dropdown in the Gmail settings for all available options, as described in the language settings help article. A table of sample values is also provided in the Managing Language Settings guide

Not all Gmail clients can display the same set of languages. In the case that a user's display language is not available for use on a particular client, said client automatically chooses to display in the closest supported variant (or a reasonable default).


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function UpdatePop-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AccessWindow,
        [Parameter()]
        [string]$Disposition,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AccessWindow = @{ OriginalName = '--accessWindow'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Disposition  = @{ OriginalName = '--disposition'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId       = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "updatePop"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates POP settings.

.PARAMETER AccessWindow
The range of messages which are accessible via POP.
[DISABLED|FROM_NOW_ON|ALL_MAIL]
DISABLED     - Indicates that no messages are accessible via POP.
FROM_NOW_ON  - Indicates that unfetched messages received after some past point in time are accessible via POP.
ALL_MAIL     - Indicates that all unfetched messages are accessible via POP.


.PARAMETER Disposition
The state that a message should be left in after it has been forwarded.
[LEAVE_IN_INBOX|ARCHIVE|TRASH|MARK_READ]
LEAVE_IN_INBOX  - Leave the message in the INBOX.
ARCHIVE         - Archive the message.
TRASH           - Move the message to the TRASH.
MARK_READ       - Leave the message in the INBOX and mark it as read.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function UpdateVacation-GmailSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$EnableAutoReply,
        [Parameter()]
        [string]$EndTime,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ResponseBodyHtml,
        [Parameter()]
        [string]$ResponseBodyPlainText,
        [Parameter()]
        [string]$ResponseSubject,
        [Parameter()]
        [switch]$RestrictToContacts,
        [Parameter()]
        [switch]$RestrictToDomain,
        [Parameter()]
        [string]$StartTime,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            EnableAutoReply       = @{ OriginalName = '--enableAutoReply'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            EndTime               = @{ OriginalName = '--endTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResponseBodyHtml      = @{ OriginalName = '--responseBodyHtml'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResponseBodyPlainText = @{ OriginalName = '--responseBodyPlainText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResponseSubject       = @{ OriginalName = '--responseSubject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RestrictToContacts    = @{ OriginalName = '--restrictToContacts'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            RestrictToDomain      = @{ OriginalName = '--restrictToDomain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            StartTime             = @{ OriginalName = '--startTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId                = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailSettings"
            "updateVacation"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates vacation responder settings.

.PARAMETER EnableAutoReply
Flag that controls whether Gmail automatically replies to messages.


.PARAMETER EndTime
An optional end time for sending auto-replies (epoch ms).
When this is specified, Gmail will automatically reply only to messages that it receives before the end time.
If both startTime and endTime are specified, startTime must precede endTime.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ResponseBodyHtml
Response body in HTML format. Gmail will sanitize the HTML before storing it.
If both responseBodyPlainText and responseBodyHtml are specified, responseBodyHtml will be used.


.PARAMETER ResponseBodyPlainText
Response body in plain text format.
If both responseBodyPlainText and responseBodyHtml are specified, responseBodyHtml will be used.


.PARAMETER ResponseSubject
Optional text to prepend to the subject line in vacation responses.
In order to enable auto-replies, either the response subject or the response body must be nonempty.


.PARAMETER RestrictToContacts
Flag that determines whether responses are sent to recipients who are not in the user's list of contacts.


.PARAMETER RestrictToDomain
Flag that determines whether responses are sent to recipients who are outside of the user's domain.
This feature is only available for Workspace users.


.PARAMETER StartTime
An optional start time for sending auto-replies (epoch ms).
When this is specified, Gmail will automatically reply only to messages that it receives after the start time.
If both startTime and endTime are specified, startTime must precede endTime.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function GetProfile-GmailUsers {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "gmailUsers"
            "getProfile"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified user's Gmail profile.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-GroupAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Alias,
        [Parameter()]
        [string]$GroupKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Alias    = @{ OriginalName = '--alias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupAliases"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes an alias.

.PARAMETER Alias
The alias.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.



#>
}


Function Insert-GroupAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Alias,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Alias    = @{ OriginalName = '--alias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupAliases"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds an alias for the group.

.PARAMETER Alias
The alias.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.



#>
}


Function List-GroupAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupAliases"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists all aliases for a group.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.



#>
}


Function CheckTransitiveMembership-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Query
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query  = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "checkTransitiveMembership"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Check a potential member for membership in a group.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.


.PARAMETER Query
A CEL expression that MUST include:
getMembershipGraph      - member specification AND label(s)
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
list                    - member specification
                          (Example query: member_key_id == 'member_key_id_value')
searchTransitiveGroups  - member specification AND label(s)
                          Users can search on label attributes of groups. CONTAINS match ('in') is supported on labels.
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
Certain groups are uniquely identified by both a 'member_key_id' and a 'member_key_namespace', which requires an additional query input: 'member_key_namespace'.



#>
}


Function Create-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MemberKeyId,
        [Parameter()]
        [string]$MemberKeyNamespace,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Roles
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email              = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKeyId        = @{ OriginalName = '--memberKeyId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKeyNamespace = @{ OriginalName = '--memberKeyNamespace'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent             = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Roles              = @{ OriginalName = '--roles'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a Membership.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MemberKeyId
The ID of the entity.

For Google-managed entities, the id must be the email address of an existing group or user.

For external-identity-mapped entities, the id must be a string conforming to the Identity Source's requirements.

Must be unique within a namespace.


.PARAMETER MemberKeyNamespace
The namespace in which the entity exists.

If not specified, the EntityKey represents a Google-managed entity such as a Google user or a Google Group.

If specified, the EntityKey represents an external-identity-mapped group. The namespace must correspond to an identity source created in Admin Console and must be in the form of identitysources/{identity_source_id}.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.


.PARAMETER Roles
The MembershipRoles that apply to the Membership.

If unspecified, defaults to a single MembershipRole with name MEMBER.

Must not contain duplicate MembershipRoles with the same name.

Can be used multiple times in the form of "--roles name=...;expiryDate...
You may use the following properties:
name  - The name of the MembershipRole.
		Must be one of OWNER, MANAGER, MEMBER.
expireTime    - The time at which the MembershipRole will expire.
				A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
				Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
                Expiry details are only supported for MEMBER MembershipRoles.



#>
}


Function Delete-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name  = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a Membership.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Name
The resource name of the Membership.
Must be of the form groups/{group_id}/memberships/{membership_id}.



#>
}


Function Get-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name   = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a Membership.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The resource name of the Membership.
Must be of the form groups/{group_id}/memberships/{membership_id}.



#>
}


Function GetMembershipGraph-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Query
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query  = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "getMembershipGraph"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
GetMembershipGraphs a Membership.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.


.PARAMETER Query
A CEL expression that MUST include:
getMembershipGraph      - member specification AND label(s)
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
list                    - member specification
                          (Example query: member_key_id == 'member_key_id_value')
searchTransitiveGroups  - member specification AND label(s)
                          Users can search on label attributes of groups. CONTAINS match ('in') is supported on labels.
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
Certain groups are uniquely identified by both a 'member_key_id' and a 'member_key_namespace', which requires an additional query input: 'member_key_namespace'.



#>
}


Function List-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$View
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            View   = @{ OriginalName = '--view'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists members of a (dynamic) group

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.


.PARAMETER View
The level of detail to be returned.
BASIC  - Default. Only basic resource information is returned.
FULL   - All resource information is returned.



#>
}


Function Lookup-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$MemberKeyId,
        [Parameter()]
        [string]$MemberKeyNamespace,
        [Parameter()]
        [string]$Parent
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email              = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKeyId        = @{ OriginalName = '--memberKeyId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKeyNamespace = @{ OriginalName = '--memberKeyNamespace'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent             = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "lookup"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Looks up a Membership.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER MemberKeyId
The ID of the entity.

For Google-managed entities, the id must be the email address of an existing group or user.

For external-identity-mapped entities, the id must be a string conforming to the Identity Source's requirements.

Must be unique within a namespace.


.PARAMETER MemberKeyNamespace
The namespace in which the entity exists.

If not specified, the EntityKey represents a Google-managed entity such as a Google user or a Google Group.

If specified, the EntityKey represents an external-identity-mapped group. The namespace must correspond to an identity source created in Admin Console and must be in the form of identitysources/{identity_source_id}.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.



#>
}


Function ModifyMembershipRoles-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddRoles,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$RemoveRoles,
        [Parameter()]
        [string]$UpdateRolesParams
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddRoles          = @{ OriginalName = '--addRoles'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name              = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RemoveRoles       = @{ OriginalName = '--removeRoles'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UpdateRolesParams = @{ OriginalName = '--updateRolesParams'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "modifyMembershipRoles"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Modifies the MembershipRoles of a Membership.

.PARAMETER AddRoles
The MembershipRoles to be added.

Adding or removing roles in the same request as updating roles is not supported.

Must not be set if updateRolesParams is set.
Can be used multiple times in the form of "--addRoles name=...;expiryDate...
You may use the following properties:
name        - The name of the MembershipRole.
              Must be one of OWNER, MANAGER, MEMBER.
expireTime  - The time at which the MembershipRole will expire.
			  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
			  Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
              Expiry details are only supported for MEMBER MembershipRoles.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The resource name of the Membership.
Must be of the form groups/{group_id}/memberships/{membership_id}.


.PARAMETER RemoveRoles
The names of the MembershipRoles to be removed.

Adding or removing roles in the same request as updating roles is not supported.

It is not possible to remove the MEMBER MembershipRole. If you wish to delete a Membership, call MembershipsService.DeleteMembership instead.

Must not contain MEMBER. Must not be set if updateRolesParams is set.


.PARAMETER UpdateRolesParams
The MembershipRoles to be updated.

Updating roles in the same request as adding or removing roles is not supported.

Must not be set if either addRoles or removeRoles is set.

Can be used multiple times in the form of "--updateRolesParams fieldMask=...;membershipRole=..."
You can use the following properties:
name        - The name of the MembershipRole.
		      Must be one of OWNER, MANAGER, MEMBER.
expireTime  - The time at which the MembershipRole will expire.
			  A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
              Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
              Expiry details are only supported for MEMBER MembershipRoles.



#>
}


Function SearchTransitiveGroups-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Query
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query  = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "searchTransitiveGroups"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Search transitive groups of a member.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.


.PARAMETER Query
A CEL expression that MUST include:
getMembershipGraph      - member specification AND label(s)
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
list                    - member specification
                          (Example query: member_key_id == 'member_key_id_value')
searchTransitiveGroups  - member specification AND label(s)
                          Users can search on label attributes of groups. CONTAINS match ('in') is supported on labels.
                          (Example query: member_key_id == 'member_key_id_value' && <label_value> in labels)
Certain groups are uniquely identified by both a 'member_key_id' and a 'member_key_namespace', which requires an additional query input: 'member_key_namespace'.



#>
}


Function SearchTransitiveMemberships-GroupMembershipsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Parent
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupMembershipsCi"
            "searchTransitiveMemberships"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Search transitive memberships of a group.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Parent
Resource name of the group.
Format: groups/{group_id}, where group_id is the unique id assigned to the Group to which the Membership belongs to.



#>
}


Function Delete-Groups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$GroupKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            GroupKey = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groups"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a group.

.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.



#>
}


Function Get-Groups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groups"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a group's properties.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.



#>
}


Function Insert-Groups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Description = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Email       = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name        = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groups"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a group.

.PARAMETER Description
An extended description to help users determine the purpose of a group.
For example, you can include information about who should join the group, the types of messages to send to the group, links to FAQs about the group, or related groups.
Maximum length is 4,096 characters.


.PARAMETER Email
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The group's display name.



#>
}


Function List-Groups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$SortOrder,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer  = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Domain    = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy   = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query     = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SortOrder = @{ OriginalName = '--sortOrder'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey   = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groups"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieve all groups of a domain or of a user given a userKey (paginated).

.PARAMETER Customer
The unique ID for the customer's Workspace account.
In case of a multi-domain account, to fetch all groups for a customer, fill this field instead of domain.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Domain
The domain name.
Use this field to get fields from only one domain.
To return all domains for a customer account, use the customer query parameter instead.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrderBy
Column to use for sorting results
Acceptable values are:
email  - Email of the group.


.PARAMETER Query
Query string search. Should be of the form "".
Complete documentation is at https://developers.google.com/admin-sdk/directory/v1/guides/search-groups


.PARAMETER SortOrder
Whether to return results in ascending or descending order. Only of use when orderBy is also used
Acceptable values are:
ASCENDING   - Ascending order.
DESCENDING  - Descending order.


.PARAMETER UserKey
Email or immutable ID of the user if only those groups are to be listed, the given user is a member of.
If it's an ID, it should match with the ID of the user object.



#>
}


Function Patch-Groups {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Description = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Email       = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey    = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name        = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groups"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a group's properties. This method supports patch semantics

.PARAMETER Description
An extended description to help users determine the purpose of a group.
For example, you can include information about who should join the group, the types of messages to send to the group, links to FAQs about the group, or related groups.
Maximum length is 4,096 characters.


.PARAMETER Email
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER Name
The group's display name.



#>
}


Function Create-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AdditionalGroupKeys,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$DisplayName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$InitialGroupConfig,
        [Parameter()]
        [string]$Labels,
        [Parameter()]
        [string]$Namespace,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$Queries
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AdditionalGroupKeys = @{ OriginalName = '--additionalGroupKeys'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description         = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DisplayName         = @{ OriginalName = '--displayName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields              = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id                  = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            InitialGroupConfig  = @{ OriginalName = '--initialGroupConfig'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Labels              = @{ OriginalName = '--labels'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Namespace           = @{ OriginalName = '--namespace'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent              = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Queries             = @{ OriginalName = '--queries'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a Group.

.PARAMETER AdditionalGroupKeys
Additional entity key aliases for a Group.
Can be used multiple times in the form of "id=...;namespace=..."


.PARAMETER Description
An extended description to help users determine the purpose of a Group.
Must not be longer than 4,096 characters.


.PARAMETER DisplayName
The display name of the Group.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the entity.

For Google-managed entities, the id must be the email address of an existing group or user.

For external-identity-mapped entities, the id must be a string conforming to the Identity Source's requirements.

Must be unique within a namespace.


.PARAMETER InitialGroupConfig
Required. The initial configuration option for the Group.
WITH_INITIAL_OWNER  - The end user making the request will be added as the initial owner of the Group.
EMPTY               - An empty group is created without any initial owners.
                      This can only be used by admins of the domain.


.PARAMETER Labels
 One or more label entries that apply to the Group. Currently supported labels contain a key with an empty value.

Google Groups are the default type of group and have a label with a key of cloudidentity.googleapis.com/groups.discussion_forum and an empty value.

Existing Google Groups can have an additional label with a key of cloudidentity.googleapis.com/groups.security and an empty value added to them. This is an immutable change and the security label cannot be removed once added.

Dynamic groups have a label with a key of cloudidentity.googleapis.com/groups.dynamic.

Identity-mapped groups for Cloud Search have a label with a key of system/groups/external and an empty value.

Examples: {"cloudidentity.googleapis.com/groups.discussion_forum": ""} or {"system/groups/external": ""}.

An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.


.PARAMETER Namespace
The namespace in which the entity exists.

If not specified, the EntityKey represents a Google-managed entity such as a Google user or a Google Group.

If specified, the EntityKey represents an external-identity-mapped group.
The namespace must correspond to an identity source created in Admin Console and must be in the form of identitysources/{identity_source_id}.


.PARAMETER Parent
Must be of the form identitysources/{identity_source_id} for external- identity-mapped groups or customers/{customer_id} for Google Groups.


.PARAMETER Queries
Memberships will be the union of all queries.
Only one entry with USER resource is currently supported.
Can be used multiple times in the form of "--queries query=...;resourceType=..."
You may use the following properties:
resourceType  - The following values are valid:
				  - USER - For queries on User
query         - Query that determines the memberships of the dynamic group.
				Examples:
			      - All users with at least one organizations.department of engineering:
                    user.organizations.exists(org, org.department=='engineering')
                  - All users with at least one location that has area of foo and building_id of bar:
                    user.locations.exists(loc, loc.area=='foo' && loc.building_id=='bar')



#>
}


Function Delete-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name  = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a Group.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Name
The resource name of the Group.

Must be of the form groups/{group_id}.



#>
}


Function Get-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name   = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a group.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The resource name of the Group.

Must be of the form groups/{group_id}.



#>
}


Function List-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Parent,
        [Parameter()]
        [string]$View
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Parent = @{ OriginalName = '--parent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            View   = @{ OriginalName = '--view'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the Groups under a customer or namespace.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Parent
Must be of the form identitysources/{identity_source_id} for external- identity-mapped groups or customers/{customer_id} for Google Groups.


.PARAMETER View
The level of detail to be returned.
BASIC  - Default. Only basic resource information is returned.
FULL   - All resource information is returned.



#>
}


Function Lookup-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email  = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "lookup"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Looks up a Group.

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Labels,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$UpdateMask
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Email      = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Labels     = @{ OriginalName = '--labels'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name       = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UpdateMask = @{ OriginalName = '--updateMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updating a Google Group to a security group

.PARAMETER Email
Email address of the group.
This may be used instead of the name to do a lookup of the group resource name.
Note that this will cause an additional API call.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Labels
 One or more label entries that apply to the Group. Currently supported labels contain a key with an empty value.

Google Groups are the default type of group and have a label with a key of cloudidentity.googleapis.com/groups.discussion_forum and an empty value.

Existing Google Groups can have an additional label with a key of cloudidentity.googleapis.com/groups.security and an empty value added to them. This is an immutable change and the security label cannot be removed once added.

Dynamic groups have a label with a key of cloudidentity.googleapis.com/groups.dynamic.

Identity-mapped groups for Cloud Search have a label with a key of system/groups/external and an empty value.

Examples: {"cloudidentity.googleapis.com/groups.discussion_forum": ""} or {"system/groups/external": ""}.

An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.


.PARAMETER Name
The resource name of the Group.

Must be of the form groups/{group_id}.


.PARAMETER UpdateMask
The fully-qualified names of fields to update.

May only contain the following fields: displayName, description.

A comma-separated list of fully qualified names of fields. Example: "user.displayName,photo".



#>
}


Function Search-GroupsCi {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$View
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query  = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            View   = @{ OriginalName = '--view'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupsCi"
            "search"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Searches for Groups matching a specified query.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Query
The search query.
Must be specified in Common Expression Language.
May only contain equality operators on the parent and inclusion operators on labels (e.g., parent == 'customers/{customer_id}' && 'cloudidentity.googleapis.com/groups.discussion_forum' in labels).


.PARAMETER View
The level of detail to be returned.
BASIC  - Default. Only basic resource information is returned.
FULL   - All resource information is returned.



#>
}


Function Get-GroupSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupUniqueId,
        [Parameter()]
        [switch]$IgnoreDeprecated
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupUniqueId    = @{ OriginalName = '--groupUniqueId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IgnoreDeprecated = @{ OriginalName = '--ignoreDeprecated'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupSettings"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a group's settings identified by the group email address.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupUniqueId
The group's email address.


.PARAMETER IgnoreDeprecated
Ignore deprecated fields.



#>
}


Function Patch-GroupSettings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AllowExternalMembers,
        [Parameter()]
        [string]$AllowWebPosting,
        [Parameter()]
        [string]$ArchiveOnly,
        [Parameter()]
        [string]$CustomFooterText,
        [Parameter()]
        [string]$CustomReplyTo,
        [Parameter()]
        [string]$DefaultMessageDenyNotificationText,
        [Parameter()]
        [string]$EnableCollaborativeInbox,
        [Parameter()]
        [string]$FavoriteRepliesOnTop,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupUniqueId,
        [Parameter()]
        [switch]$IgnoreDeprecated,
        [Parameter()]
        [string]$IncludeCustomFooter,
        [Parameter()]
        [string]$IncludeInGlobalAddressList,
        [Parameter()]
        [string]$IsArchived,
        [Parameter()]
        [string]$MembersCanPostAsTheGroup,
        [Parameter()]
        [string]$MessageModerationLevel,
        [Parameter()]
        [string]$PrimaryLanguage,
        [Parameter()]
        [string]$ReplyTo,
        [Parameter()]
        [string]$SendMessageDenyNotification,
        [Parameter()]
        [string]$SpamModerationLevel,
        [Parameter()]
        [string]$WhoCanApproveMembers,
        [Parameter()]
        [string]$WhoCanAssistContent,
        [Parameter()]
        [string]$WhoCanBanUsers,
        [Parameter()]
        [string]$WhoCanContactOwner,
        [Parameter()]
        [string]$WhoCanDiscoverGroup,
        [Parameter()]
        [string]$WhoCanJoin,
        [Parameter()]
        [string]$WhoCanLeaveGroup,
        [Parameter()]
        [string]$WhoCanModerateContent,
        [Parameter()]
        [string]$WhoCanModerateMembers,
        [Parameter()]
        [string]$WhoCanPostMessage,
        [Parameter()]
        [string]$WhoCanViewGroup,
        [Parameter()]
        [string]$WhoCanViewMembership
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AllowExternalMembers               = @{ OriginalName = '--allowExternalMembers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AllowWebPosting                    = @{ OriginalName = '--allowWebPosting'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ArchiveOnly                        = @{ OriginalName = '--archiveOnly'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomFooterText                   = @{ OriginalName = '--customFooterText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomReplyTo                      = @{ OriginalName = '--customReplyTo'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DefaultMessageDenyNotificationText = @{ OriginalName = '--defaultMessageDenyNotificationText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EnableCollaborativeInbox           = @{ OriginalName = '--enableCollaborativeInbox'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FavoriteRepliesOnTop               = @{ OriginalName = '--favoriteRepliesOnTop'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupUniqueId                      = @{ OriginalName = '--groupUniqueId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IgnoreDeprecated                   = @{ OriginalName = '--ignoreDeprecated'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IncludeCustomFooter                = @{ OriginalName = '--includeCustomFooter'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeInGlobalAddressList         = @{ OriginalName = '--includeInGlobalAddressList'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IsArchived                         = @{ OriginalName = '--isArchived'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MembersCanPostAsTheGroup           = @{ OriginalName = '--membersCanPostAsTheGroup'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MessageModerationLevel             = @{ OriginalName = '--messageModerationLevel'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrimaryLanguage                    = @{ OriginalName = '--primaryLanguage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyTo                            = @{ OriginalName = '--replyTo'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendMessageDenyNotification        = @{ OriginalName = '--sendMessageDenyNotification'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SpamModerationLevel                = @{ OriginalName = '--spamModerationLevel'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanApproveMembers               = @{ OriginalName = '--whoCanApproveMembers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanAssistContent                = @{ OriginalName = '--whoCanAssistContent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanBanUsers                     = @{ OriginalName = '--whoCanBanUsers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanContactOwner                 = @{ OriginalName = '--whoCanContactOwner'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanDiscoverGroup                = @{ OriginalName = '--whoCanDiscoverGroup'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanJoin                         = @{ OriginalName = '--whoCanJoin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanLeaveGroup                   = @{ OriginalName = '--whoCanLeaveGroup'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanModerateContent              = @{ OriginalName = '--whoCanModerateContent'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanModerateMembers              = @{ OriginalName = '--whoCanModerateMembers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanPostMessage                  = @{ OriginalName = '--whoCanPostMessage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanViewGroup                    = @{ OriginalName = '--whoCanViewGroup'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            WhoCanViewMembership               = @{ OriginalName = '--whoCanViewMembership'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "groupSettings"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates an existing resource. This method supports patch semantics.

.PARAMETER AllowExternalMembers
Identifies whether members external to your organization can join the group.
true   - Workspace users external to your organization can become members of this group.
false  - Users not belonging to the organization are not allowed to become members of this group.


.PARAMETER AllowWebPosting
Allows posting from web.
true   - Allows any member to post to the group forum.
false  - Members only use Gmail to communicate with the group.


.PARAMETER ArchiveOnly
Allows the group to be archived only.
true   - Group is archived and the group is inactive. New messages to this group are rejected. The older archived messages are browseable and searchable.
           - If true, the whoCanPostMessage property is set to NONE_CAN_POST.
           - If reverted from true to false, whoCanPostMessages is set to ALL_MANAGERS_CAN_POST.
false  - The group is active and can receive messages.
		   - When false, updating whoCanPostMessage to NONE_CAN_POST, results in an error.


.PARAMETER CustomFooterText
Set the content of custom footer text.
The maximum number of characters is 1000.


.PARAMETER CustomReplyTo
An email address used when replying to a message if the replyTo property is set to REPLY_TO_CUSTOM.
This address is defined by an account administrator.
When the group's ReplyTo property is set to REPLY_TO_CUSTOM, the customReplyTo property holds a custom email address used when replying to a message.
If the group's ReplyTo property is set to REPLY_TO_CUSTOM, the customReplyTo property must have a text value or an error is returned.


.PARAMETER DefaultMessageDenyNotificationText
When a message is rejected, this is text for the rejection notification sent to the message's author.
By default, this property is empty and has no value in the API's response body.
The maximum notification text size is 10,000 characters.


.PARAMETER EnableCollaborativeInbox
Specifies whether a collaborative inbox will remain turned on for the group.


.PARAMETER FavoriteRepliesOnTop
Indicates if favorite replies should be displayed above other replies.
true   - Favorite replies will be displayed above other replies.
false  - Favorite replies will not be displayed above other replies.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupUniqueId
The group's email address.


.PARAMETER IgnoreDeprecated
Ignore deprecated fields.


.PARAMETER IncludeCustomFooter
Whether to include custom footer.


.PARAMETER IncludeInGlobalAddressList
Enables the group to be included in the Global Address List. For more information, see the help center.
true   - Group is included in the Global Address List.
false  - Group is not included in the Global Address List.


.PARAMETER IsArchived
Allows the Group contents to be archived.
true   - Archive messages sent to the group.
false  - Do not keep an archive of messages sent to this group.
         If false, previously archived messages remain in the archive.


.PARAMETER MembersCanPostAsTheGroup
Enables members to post messages as the group.
true   - Group member can post messages using the group's email address instead of their own email address.
         Message appear to originate from the group itself.
         Note: When true, any message moderation settings on individual users or new members do not apply to posts made on behalf of the group.
false  - Members can not post in behalf of the group's email address.


.PARAMETER MessageModerationLevel
Moderation level of incoming messages.
[MODERATE_ALL_MESSAGES|MODERATE_NON_MEMBERS|MODERATE_NEW_MEMBERS|MODERATE_NONE]
MODERATE_ALL_MESSAGES  - All messages are sent to the group owner's email address for approval. If approved, the message is sent to the group.
MODERATE_NON_MEMBERS   - All messages from non group members are sent to the group owner's email address for approval. If approved, the message is sent to the group.
MODERATE_NEW_MEMBERS   - All messages from new members are sent to the group owner's email address for approval. If approved, the message is sent to the group.
MODERATE_NONE          - No moderator approval is required. Messages are delivered directly to the group.


.PARAMETER PrimaryLanguage
The primary language for group.
For a group's primary language use the language tags from the Workspace languages found at Workspace Email Settings API Email Language Tags.


.PARAMETER ReplyTo
Specifies who the default reply should go to.
[REPLY_TO_CUSTOM|REPLY_TO_SENDER|REPLY_TO_LIST|REPLY_TO_OWNER|REPLY_TO_IGNORE|REPLY_TO_MANAGERS]
REPLY_TO_CUSTOM    - For replies to messages, use the group's custom email address.
					   - When the group's ReplyTo property is set to REPLY_TO_CUSTOM, the customReplyTo property holds the custom email address used when replying to a message.
						 If the group's ReplyTo property is set to REPLY_TO_CUSTOM, the customReplyTo property must have a value.
						 Otherwise an error is returned.

REPLY_TO_SENDER    - The reply sent to author of message.
REPLY_TO_LIST      - This reply message is sent to the group.
REPLY_TO_OWNER     - The reply is sent to the owners of the group. This doesn't include the group's managers.
REPLY_TO_IGNORE    - Group users individually decide where the message reply is sent.
REPLY_TO_MANAGERS  - This reply message is sent to the group's managers, which includes all managers and the group owner.


.PARAMETER SendMessageDenyNotification
Allows a member to be notified if the member's message to the group is denied by the group owner.
true   - When a message is rejected, send the deny message notification to the message author.
         The defaultMessageDenyNotificationText property is dependent on the sendMessageDenyNotification property being true.

false  - When a message is rejected, no notification is sent.


.PARAMETER SpamModerationLevel
Specifies moderation levels for messages detected as spam.
[ALLOW|MODERATE|SILENTLY_MODERATE|REJECT]
ALLOW              - Post the message to the group.
MODERATE           - Send the message to the moderation queue. This is the default.
SILENTLY_MODERATE  - Send the message to the moderation queue, but do not send notification to moderators.
REJECT             - Immediately reject the message.


.PARAMETER WhoCanApproveMembers
Specifies who can approve members who ask to join groups.
This permission will be deprecated once it is merged into the new whoCanModerateMembers setting.
[ALL_MEMBERS_CAN_APPROVE]ALL_MANAGERS_CAN_APPROVE]ALL_OWNERS_CAN_APPROVE|NONE_CAN_APPROVE]


.PARAMETER WhoCanAssistContent
Specifies who can moderate metadata.
[ALL_MEMBERS|OWNERS_AND_MANAGERS|OWNERS_ONLY|NONE]


.PARAMETER WhoCanBanUsers
Specifies who can deny membership to users.
This permission will be deprecated once it is merged into the new whoCanModerateMembers setting.
[ALL_MEMBERS|OWNERS_AND_MANAGERS|OWNERS_ONLY|NONE]


.PARAMETER WhoCanContactOwner
Specifies who can contact the group owner.
[ALL_IN_DOMAIN_CAN_CONTACT|ALL_MANAGERS_CAN_CONTACT|ALL_MEMBERS_CAN_CONTACT|ANYONE_CAN_CONTACT]


.PARAMETER WhoCanDiscoverGroup
Specifies the set of users for whom this group is discoverable.
[ANYONE_CAN_DISCOVER|ALL_IN_DOMAIN_CAN_DISCOVER|ALL_MEMBERS_CAN_DISCOVER]


.PARAMETER WhoCanJoin
Permission to join group.
[ANYONE_CAN_JOIN|ALL_IN_DOMAIN_CAN_JOIN|INVITED_CAN_JOIN|CAN_REQUEST_TO_JOIN]
ANYONE_CAN_JOIN         - Any Internet user, both inside and outside your domain, can join the group.
ALL_IN_DOMAIN_CAN_JOIN  - Anyone in the account domain can join. This includes accounts with multiple domains.
INVITED_CAN_JOIN        - Candidates for membership can be invited to join.
CAN_REQUEST_TO_JOIN     - Non members can request an invitation to join.


.PARAMETER WhoCanLeaveGroup
Specifies who can leave the group.
[ALL_MANAGERS_CAN_LEAVE|ALL_MEMBERS_CAN_LEAVE|NONE_CAN_LEAVE]


.PARAMETER WhoCanModerateContent
Specifies who can moderate content.
[ALL_MEMBERS|OWNERS_AND_MANAGERS|OWNERS_ONLY|NONE]


.PARAMETER WhoCanModerateMembers
Specifies who can manage members.
[ALL_MEMBERS|OWNERS_AND_MANAGERS|OWNERS_ONLY|NONE]


.PARAMETER WhoCanPostMessage
Permissions to post messages.
[NONE_CAN_POST|ALL_MANAGERS_CAN_POST|ALL_MEMBERS_CAN_POST|ALL_OWNERS_CAN_POST|ALL_IN_DOMAIN_CAN_POST|ANYONE_CAN_POST]
NONE_CAN_POST           - The group is disabled and archived. No one can post a message to this group.
                            - When archiveOnly is false, updating whoCanPostMessage to NONE_CAN_POST, results in an error.
                            - If archiveOnly is reverted from true to false, whoCanPostMessages is set to ALL_MANAGERS_CAN_POST.
ALL_MANAGERS_CAN_POST   - Managers, including group owners, can post messages.
ALL_MEMBERS_CAN_POST    - Any group member can post a message.
ALL_OWNERS_CAN_POST     - Only group owners can post a message.
ALL_IN_DOMAIN_CAN_POST  - Anyone in the account can post a message.
ANYONE_CAN_POST         - Any Internet user who outside your account can access your Google Groups service and post a message.


.PARAMETER WhoCanViewGroup
Permissions to view group messages.
[ANYONE_CAN_VIEW|ALL_IN_DOMAIN_CAN_VIEW|ALL_MEMBERS_CAN_VIEW|ALL_OWNERS_CAN_VIEW]
ANYONE_CAN_VIEW         - Any Internet user can view the group's messages.
ALL_IN_DOMAIN_CAN_VIEW  - Anyone in your account can view this group's messages.
ALL_MEMBERS_CAN_VIEW    - All group members can view the group's messages.
ALL_MANAGERS_CAN_VIEW   - Any group manager can view this group's messages.
ALL_OWNERS_CAN_VIEW     - Any group owner can view this group's messages.


.PARAMETER WhoCanViewMembership
Permissions to view membership.
[ALL_IN_DOMAIN_CAN_VIEW|ALL_MEMBERS_CAN_VIEW|ALL_MANAGERS_CAN_VIEW]
ALL_IN_DOMAIN_CAN_VIEW  - Anyone in the account can view the group members list.
                          If a group already has external members, those members can still send email to this group.
ALL_MEMBERS_CAN_VIEW    - The group members can view the group members list.
ALL_MANAGERS_CAN_VIEW   - The group managers can view group members list.



#>
}


Function List-History {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$HistoryTypes,
        [Parameter()]
        [string]$LabelId,
        [Parameter()]
        [string]$StartHistoryId,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HistoryTypes   = @{ OriginalName = '--historyTypes'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            LabelId        = @{ OriginalName = '--labelId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StartHistoryId = @{ OriginalName = '--startHistoryId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "history"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the history of all changes to the given mailbox. History results are returned in chronological order (increasing historyId).

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER HistoryTypes
History types to be returned by the function.
[MESSAGE_ADDED|MESSAGE_DELETED|LABEL_ADDED|LABEL_REMOVED]


.PARAMETER LabelId
Only return messages with a label matching the ID.


.PARAMETER StartHistoryId
Required. Returns history records after the specified startHistoryId.
The supplied startHistoryId should be obtained from the historyId of a message, thread, or previous list response.
History IDs increase chronologically but are not contiguous with random gaps in between valid IDs.


.PARAMETER UserId
The user's email address.
The special value me can be used to indicate the authenticated user.



#>
}


Function Create-Labels {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BackgroundColor,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$LabelListVisibility,
        [Parameter()]
        [string]$MessageListVisibility,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$TextColor,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BackgroundColor       = @{ OriginalName = '--backgroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            LabelListVisibility   = @{ OriginalName = '--labelListVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MessageListVisibility = @{ OriginalName = '--messageListVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                  = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TextColor             = @{ OriginalName = '--textColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId                = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "labels"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new label.

.PARAMETER BackgroundColor
Background color


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER LabelListVisibility
The visibility of the label in the label list in the Gmail web interface. [LABEL_SHOW|LABEL_SHOW_IF_UNREAD|LABEL_HIDE]


.PARAMETER MessageListVisibility
The visibility of messages with this label in the message list in the Gmail web interface. [SHOW|HIDE]


.PARAMETER Name
The display name of the label.


.PARAMETER TextColor
Text color


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-Labels {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "labels"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Immediately and permanently deletes the specified label and removes it from any messages and threads that it is applied to.

.PARAMETER Id
The ID of the label


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Get-Labels {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "labels"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified label.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the label


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function List-Labels {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "labels"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists all labels in the user's mailbox.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Patch-Labels {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BackgroundColor,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$LabelListVisibility,
        [Parameter()]
        [string]$MessageListVisibility,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$TextColor,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BackgroundColor       = @{ OriginalName = '--backgroundColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id                    = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            LabelListVisibility   = @{ OriginalName = '--labelListVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MessageListVisibility = @{ OriginalName = '--messageListVisibility'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name                  = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TextColor             = @{ OriginalName = '--textColor'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId                = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "labels"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patch the specified label.

.PARAMETER BackgroundColor
Background color


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the label


.PARAMETER LabelListVisibility
The visibility of the label in the label list in the Gmail web interface. [LABEL_SHOW|LABEL_SHOW_IF_UNREAD|LABEL_HIDE]


.PARAMETER MessageListVisibility
The visibility of messages with this label in the message list in the Gmail web interface. [SHOW|HIDE]


.PARAMETER Name
The display name of the label.


.PARAMETER TextColor
Text color


.PARAMETER UserId
The user's email address. The special value "me" can be used to indicate the authenticated user.



#>
}


Function Delete-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ProductId,
        [Parameter()]
        [string]$SkuId,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ProductId = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuId     = @{ OriginalName = '--skuId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId    = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a specific user's license by product SKU.

.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuId
A product SKU's unique identifier.
For more information about available SKUs in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER UserId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.



#>
}


Function Get-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ProductId,
        [Parameter()]
        [string]$SkuId,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ProductId = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuId     = @{ OriginalName = '--skuId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId    = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Get a specific user's license by product SKU.

.PARAMETER Fields
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuId
A product SKU's unique identifier.
For more information about available SKUs in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER UserId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.



#>
}


Function Insert-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ProductId,
        [Parameter()]
        [string]$SkuId,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ProductId = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuId     = @{ OriginalName = '--skuId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId    = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Insert a specific user's license by product SKU.

.PARAMETER Fields
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuId
A product SKU's unique identifier.
For more information about available SKUs in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER UserId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.



#>
}


Function ListForProduct-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ProductId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ProductId  = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "listForProduct"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List all users assigned licenses for a specific product SKU.

.PARAMETER CustomerId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER Fields
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.



#>
}


Function ListForProductAndSku-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ProductId,
        [Parameter()]
        [string]$SkuId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ProductId  = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuId      = @{ OriginalName = '--skuId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "listForProductAndSku"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List all users assigned licenses for a specific product SKU.

.PARAMETER CustomerId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER Fields
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuId
A product SKU's unique identifier.
For more information about available SKUs in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.



#>
}


Function Patch-LicenseAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ProductId,
        [Parameter()]
        [string]$SkuId,
        [Parameter()]
        [string]$SkuIdNew,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ProductId = @{ OriginalName = '--productId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuId     = @{ OriginalName = '--skuId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SkuIdNew  = @{ OriginalName = '--skuIdNew'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId    = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "licenseAssignments"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patch a specific user's license by product SKU.

.PARAMETER Fields
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.


.PARAMETER ProductId
A product's unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuId
A product SKU's unique identifier.
For more information about available SKUs in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER SkuIdNew
The product's new unique identifier.
For more information about products in this version of the API, see https://developers.google.com/admin-sdk/licensing/v1/how-tos/products.


.PARAMETER UserId
The user's current primary email address.
If the user's email address changes, use the new email address in your API requests.
Since a userId is subject to change, do not use a userId value as a key for persistent data.
This key could break if the current user's email address changes.
If the userId is suspended, the license status changes.



#>
}


Function Delete-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$MemberKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            GroupKey  = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKey = @{ OriginalName = '--memberKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes a member from a group.

.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER MemberKey
Identifies the group member in the API request.
A group member can be a user or another group.
The value can be the member's (group or user) primary email address, alias, or unique ID.



#>
}


Function Get-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$MemberKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey  = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKey = @{ OriginalName = '--memberKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a group member's properties.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER MemberKey
Identifies the group member in the API request.
A group member can be a user or another group.
The value can be the member's (group or user) primary email address, alias, or unique ID.



#>
}


Function HasMember-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$MemberKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            GroupKey  = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MemberKey = @{ OriginalName = '--memberKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "hasMember"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Checks whether the given user is a member of the group. Membership can be direct or nested.

.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER MemberKey
Identifies the group member in the API request.
A group member can be a user or another group.
The value can be the member's (group or user) primary email address, alias, or unique ID.



#>
}


Function Insert-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Delivery_settings,
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$Role
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Delivery_settings = @{ OriginalName = '--delivery_settings'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Email             = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey          = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Role              = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds a user or group to the specified group.

.PARAMETER Delivery_settings
Defines mail delivery preferences of member.
Acceptable values are:
ALL_MAIL  - All messages, delivered as soon as they arrive.
DAILY     - No more than one message a day.
DIGEST    - Up to 25 messages bundled into a single message.
DISABLED  - Remove subscription.
NONE      - No messages.


.PARAMETER Email
The member's email address. A member can be a user or another group.
This property is required when adding a member to a group.
The email must be unique and cannot be an alias of another group.
If the email address is changed, the API automatically reflects the email address changes.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER Role
The member's role in a group. The API returns an error for cycles in group memberships. For example, if group1 is a member of group2, group2 cannot be a member of group1. For more information about a member's role, see the administration help center.

Acceptable values are:
MANAGER  - This role is only available if the Google Groups for Business is enabled using the Admin console. A MANAGER role can do everything done by an OWNER role except make a member an OWNER or delete the group. A group can have multiple MANAGER members.
MEMBER   - This role can subscribe to a group, view discussion archives, and view the group's membership list. For more information about member roles, see the administration help center.
OWNER    - This role can send messages to the group, add or remove members, change member roles, change group's settings, and delete the group. An OWNER must be a member of the group. A group can have more than one OWNER.



#>
}


Function List-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [switch]$IncludeDerivedMembership,
        [Parameter()]
        [string]$Roles
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields                   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey                 = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeDerivedMembership = @{ OriginalName = '--includeDerivedMembership'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Roles                    = @{ OriginalName = '--roles'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of all members in a group.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER IncludeDerivedMembership
Whether to list indirect memberships.


.PARAMETER Roles
The roles query parameter allows you to retrieve group members by role.
Allowed values are OWNER, MANAGER, and MEMBER.



#>
}


Function Patch-Members {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Delivery_settings,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GroupKey,
        [Parameter()]
        [string]$Role
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Delivery_settings = @{ OriginalName = '--delivery_settings'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GroupKey          = @{ OriginalName = '--groupKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Role              = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "members"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates the membership properties of a user in the specified group. This method supports patch semantics.

.PARAMETER Delivery_settings
Defines mail delivery preferences of member.
Acceptable values are:
ALL_MAIL  - All messages, delivered as soon as they arrive.
DAILY     - No more than one message a day.
DIGEST    - Up to 25 messages bundled into a single message.
DISABLED  - Remove subscription.
NONE      - No messages.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GroupKey
Identifies the group in the API request.
The value can be the group's email address, group alias, or the unique group ID.


.PARAMETER Role
The member's role in a group. The API returns an error for cycles in group memberships. For example, if group1 is a member of group2, group2 cannot be a member of group1. For more information about a member's role, see the administration help center.

Acceptable values are:
MANAGER  - This role is only available if the Google Groups for Business is enabled using the Admin console. A MANAGER role can do everything done by an OWNER role except make a member an OWNER or delete the group. A group can have multiple MANAGER members.
MEMBER   - This role can subscribe to a group, view discussion archives, and view the group's membership list. For more information about member roles, see the administration help center.
OWNER    - This role can send messages to the group, add or remove members, change member roles, change group's settings, and delete the group. An OWNER must be a member of the group. A group can have more than one OWNER.



#>
}


Function BatchDelete-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Ids
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Ids = @{ OriginalName = '--ids'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "batchDelete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes many messages by message ID. Provides no guarantees that messages were not already deleted or even existed at all.

.PARAMETER Ids
The IDs of the messages. There is a limit of 1000 ids per request.



#>
}


Function Delete-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Immediately and permanently deletes the specified message. This operation cannot be undone. Prefer messages.trash instead.

.PARAMETER Id
The ID of the message.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Get-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Format,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$MetadataHeaders,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Format          = @{ OriginalName = '--format'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id              = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MetadataHeaders = @{ OriginalName = '--metadataHeaders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified message.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Format
The format to return the message in.
[MINIMAL|FULL|RAW|METADATA]
MINIMAL   - Returns only email message ID and labels; does not return the email headers, body, or payload.
FULL      - Returns the full email message data with body content parsed in the payload field; the raw field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
RAW       - Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
METADATA  - Returns only email message ID, labels, and email headers.


.PARAMETER Id
The ID of the message.


.PARAMETER MetadataHeaders
When given and format is METADATA, only include headers specified.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Import-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$Deleted,
        [Parameter()]
        [string]$Eml,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$InternalDateSource,
        [Parameter()]
        [switch]$NeverMarkSpam,
        [Parameter()]
        [switch]$ProcessForCalendar,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Deleted            = @{ OriginalName = '--deleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Eml                = @{ OriginalName = '--eml'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            InternalDateSource = @{ OriginalName = '--internalDateSource'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NeverMarkSpam      = @{ OriginalName = '--neverMarkSpam'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ProcessForCalendar = @{ OriginalName = '--processForCalendar'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UserId             = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "import"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Imports a message into only this user's mailbox, with standard email delivery scanning and classification similar to receiving via SMTP.
Does not send a message.

.PARAMETER Deleted
Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator.
Only used for Workspace accounts.


.PARAMETER Eml
Path to the local .eml file


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER InternalDateSource
Source for Gmail's internal date of the message. [DATE_HEADER|RECEIVED_TIME]


.PARAMETER NeverMarkSpam
Ignore the Gmail spam classifier decision and never mark this email as SPAM in the mailbox.


.PARAMETER ProcessForCalendar
Process calendar invites in the email and add any extracted meetings to the Google Calendar for this user.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Insert-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$Deleted,
        [Parameter()]
        [string]$Eml,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$InternalDateSource,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Deleted            = @{ OriginalName = '--deleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Eml                = @{ OriginalName = '--eml'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            InternalDateSource = @{ OriginalName = '--internalDateSource'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId             = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Directly inserts a message into only this user's mailbox similar to IMAP APPEND, bypassing most scanning and classification.
Does not send a message.

.PARAMETER Deleted
Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator.
Only used for Workspace accounts.


.PARAMETER Eml
Path to the local .eml file


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER InternalDateSource
Source for Gmail's internal date of the message. [DATE_HEADER|RECEIVED_TIME]


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function List-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeSpamTrash,
        [Parameter()]
        [string]$LabelIds,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeSpamTrash = @{ OriginalName = '--includeSpamTrash'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            LabelIds         = @{ OriginalName = '--labelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Q                = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId           = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the messages in the user's mailbox.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeSpamTrash
Include messages from SPAM and TRASH in the results.


.PARAMETER LabelIds
Only return messages with labels that match all of the specified label IDs.


.PARAMETER Q
Only return messages matching the specified query.
Supports the same query format as the Gmail search box.
For example, "from:someuser@example.com rfc822msgid:<somemsgid@example.com> is:unread".
Parameter cannot be used when accessing the api using the gmail.metadata scope.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Modify-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddLabelIds,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$RemoveLabelIds,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddLabelIds    = @{ OriginalName = '--addLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id             = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RemoveLabelIds = @{ OriginalName = '--removeLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "modify"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Modifies the labels on the specified message.

.PARAMETER AddLabelIds
A list of label IDs to add to messages.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the message.


.PARAMETER RemoveLabelIds
A list of label IDs to remove from messages.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Send-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Bcc,
        [Parameter()]
        [string]$Body,
        [Parameter()]
        [string]$Cc,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Subject,
        [Parameter()]
        [string]$To,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Bcc     = @{ OriginalName = '--bcc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Body    = @{ OriginalName = '--body'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Cc      = @{ OriginalName = '--cc'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Subject = @{ OriginalName = '--subject'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            To      = @{ OriginalName = '--to'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId  = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "send"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Sends the specified message to the recipients in the To, Cc, and Bcc headers.

.PARAMETER Bcc
Blind Copy (Bcc)


.PARAMETER Body
Body or content of the (draft) message


.PARAMETER Cc
Copy (Cc)


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Subject
Subject of the (draft) message


.PARAMETER To
Recipient of the (draft) message


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Trash-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "trash"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Moves the specified message to the trash.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the message.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Untrash-Messages {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "messages"
            "untrash"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes the specified message from the trash.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The ID of the message.


.PARAMETER UserId
The user's email address. The special value \"me\" can be used to indicate the authenticated user.



#>
}


Function Action-MobileDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Action,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$ResourceId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Action     = @{ OriginalName = '--action'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceId = @{ OriginalName = '--resourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "mobileDevices"
            "action"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Takes an action that affects a mobile device. For example, remotely wiping a device.

.PARAMETER Action
The action to be performed on the device.
[admin_account_wipe|admin_remote_wipe|approve|approve|block|cancel_remote_wipe_then_activate|cancel_remote_wipe_then_block]
admin_account_wipe                - Remotely wipes only Workspace data from the device. See the administration help center for more information.
admin_remote_wipe                 - Remotely wipes all data on the device. See the administration help center for more information.
approve                           - Approves the device. If you've selected Enable device activation, devices that register after the device activation setting is enabled will need to be approved before they can start syncing with your domain. Enabling device activation forces the device user to install the Device Policy app to sync with Workspace.
block                             - Blocks access to Workspace data (mail, calendar, and contacts) on the device. The user can still access their mail, calendar, and contacts from a desktop computer or mobile browser.
cancel_remote_wipe_then_activate  - Cancels a remote wipe of the device and then reactivates it.
cancel_remote_wipe_then_block     - Cancels a remote wipe of the device and then blocks it.


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER ResourceId
The unique ID the API service uses to identify the mobile device.



#>
}


Function Delete-MobileDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$ResourceId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceId = @{ OriginalName = '--resourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "mobileDevices"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes a mobile device.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER ResourceId
The unique ID the API service uses to identify the mobile device.



#>
}


Function Get-MobileDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Projection,
        [Parameter()]
        [string]$ResourceId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceId = @{ OriginalName = '--resourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "mobileDevices"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a mobile device's properties.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Projection
Restrict information returned to a set of selected fields.
Acceptable values are:
BASIC  - Includes only the basic metadata fields (e.g., deviceId, model, status, type, and status)
FULL   - Includes all metadata fields


.PARAMETER ResourceId
The unique ID the API service uses to identify the mobile device.



#>
}


Function List-MobileDevices {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$Projection,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$SortOrder
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy    = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query      = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SortOrder  = @{ OriginalName = '--sortOrder'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "mobileDevices"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of all mobile devices for an account.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrderBy
Device property to use for sorting results.
Acceptable values are:
deviceId  - The serial number for a Google Sync mobile device. For Android devices, this is a software generated unique identifier.
email     - The device owner's email address.
lastSync  - Last policy settings sync date time of the device.
model     - The mobile device's model.
name      - The device owner's user name.
os        - The device's operating system.
status    - The device status.
type      - Type of the device.


.PARAMETER Projection
Restrict information returned to a set of selected fields.
Acceptable values are:
BASIC  - Includes only the basic metadata fields (e.g., deviceId, model, status, type, and status)
FULL   - Includes all metadata fields


.PARAMETER Query
Search string in the format provided by List query operators.
See https://developers.google.com/admin-sdk/directory/v1/list-query-operators


.PARAMETER SortOrder
Whether to return results in ascending or descending order. Must be used with the orderBy parameter.
Acceptable values are:
ASCENDING   - Ascending order.
DESCENDING  - Descending order.



#>
}


Function Delete-OrgUnits {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$OrgUnitPath
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "orgUnits"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes an organizational unit.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.



#>
}


Function Get-OrgUnits {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrgUnitPath
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "orgUnits"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves an organizational unit.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.



#>
}


Function Insert-OrgUnits {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$BlockInheritance,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$ParentOrgUnitId,
        [Parameter()]
        [string]$ParentOrgUnitPath,
        [Parameter()]
        [string]$Type
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BlockInheritance  = @{ OriginalName = '--blockInheritance'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CustomerId        = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description       = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name              = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentOrgUnitId   = @{ OriginalName = '--parentOrgUnitId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentOrgUnitPath = @{ OriginalName = '--parentOrgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Type              = @{ OriginalName = '--type'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "orgUnits"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds an organizational unit.

.PARAMETER BlockInheritance
Determines if a sub-organizational unit can inherit the settings of the parent organization.
The default value is false, meaning a sub-organizational unit inherits the settings of the nearest parent organizational unit.
For more information on inheritance and users in an organization structure, see the administration help center.


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Description
Description of the organizational unit.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The organizational unit's path name.
For example, an organizational unit's name within the /corp/support/sales_support parent path is sales_support.


.PARAMETER ParentOrgUnitId
The unique ID of the parent organizational unit.
Required, unless parentOrgUnitPath is set.


.PARAMETER ParentOrgUnitPath
The organizational unit's parent path.
For example, /corp/sales is the parent path for /corp/sales/sales_support organizational unit.
Required, unless parentOrgUnitId is set.


.PARAMETER Type
Whether to return all sub-organizations or just immediate children.
Acceptable values are:
all       - All sub-organizational units.
children  - Immediate children only (default).



#>
}


Function List-OrgUnits {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$Type
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId  = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Type        = @{ OriginalName = '--type'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "orgUnits"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a list of all organizational units for an account.

.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.


.PARAMETER Type
Whether to return all sub-organizations or just immediate children.
Acceptable values are:
all       - All sub-organizational units.
children  - Immediate children only (default).



#>
}


Function Patch-OrgUnits {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$BlockInheritance,
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$ParentOrgUnitId,
        [Parameter()]
        [string]$ParentOrgUnitPath,
        [Parameter()]
        [string]$Type
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BlockInheritance  = @{ OriginalName = '--blockInheritance'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CustomerId        = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description       = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields            = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name              = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath       = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentOrgUnitId   = @{ OriginalName = '--parentOrgUnitId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ParentOrgUnitPath = @{ OriginalName = '--parentOrgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Type              = @{ OriginalName = '--type'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "orgUnits"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates an organizational unit. This method supports patch semantics.

.PARAMETER BlockInheritance
Determines if a sub-organizational unit can inherit the settings of the parent organization.
The default value is false, meaning a sub-organizational unit inherits the settings of the nearest parent organizational unit.
For more information on inheritance and users in an organization structure, see the administration help center.


.PARAMETER CustomerId
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.


.PARAMETER Description
Description of the organizational unit.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The organizational unit's path name.
For example, an organizational unit's name within the /corp/support/sales_support parent path is sales_support.


.PARAMETER OrgUnitPath
The full path of the organizational unit or its unique ID.


.PARAMETER ParentOrgUnitId
The unique ID of the parent organizational unit.
Required, unless parentOrgUnitPath is set.


.PARAMETER ParentOrgUnitPath
The organizational unit's parent path.
For example, /corp/sales is the parent path for /corp/sales/sales_support organizational unit.
Required, unless parentOrgUnitId is set.


.PARAMETER Type
Whether to return all sub-organizations or just immediate children.
Acceptable values are:
all       - All sub-organizational units.
children  - Immediate children only (default).



#>
}


Function CopyOtherContactToMyContactsGroup-OtherContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CopyMask,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ReadMask,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CopyMask     = @{ OriginalName = '--copyMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadMask     = @{ OriginalName = '--readMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "otherContacts"
            "copyOtherContactToMyContactsGroup"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Copies an "Other contact" to a new contact in the user's "myContacts" group.

.PARAMETER CopyMask
A field mask to restrict which fields are copied into the new contact.
Valid values are:
  - emailAddresses
  - names
  - phoneNumbers


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ReadMask
A field mask to restrict which fields on the person are returned. Multiple fields can be specified by separating them with commas.
Defaults to the copy mask with metadata and membership fields if not set.
Valid values are:
  - addresses
  - ageRanges
  - biographies
  - birthdays
  - calendarUrls
  - clientData
  - coverPhotos
  - emailAddresses
  - events
  - externalIds
  - genders
  - imClients
  - interests
  - locales
  - locations
  - memberships
  - metadata
  - miscKeywords
  - names
  - nicknames
  - occupations
  - organizations
  - phoneNumbers
  - photos
  - relations
  - sipAddresses
  - skills
  - urls
  - userDefined


.PARAMETER ResourceName
The resource name of the "Other contact".


.PARAMETER Sources
A mask of what source types to return.
READ_SOURCE_TYPE_PROFILE         - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT         - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT  - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function List-OtherContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$ReadMask
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadMask = @{ OriginalName = '--readMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "otherContacts"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List all "Other contacts", that is contacts that are not in a contact group.
"Other contacts" are typically auto created contacts from interactions.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER ReadMask
A field mask to restrict which fields on the person are returned. Multiple fields can be specified by separating them with commas.
Defaults to the copy mask with metadata and membership fields if not set.
Valid values are:
  - addresses
  - ageRanges
  - biographies
  - birthdays
  - calendarUrls
  - clientData
  - coverPhotos
  - emailAddresses
  - events
  - externalIds
  - genders
  - imClients
  - interests
  - locales
  - locations
  - memberships
  - metadata
  - miscKeywords
  - names
  - nicknames
  - occupations
  - organizations
  - phoneNumbers
  - photos
  - relations
  - sipAddresses
  - skills
  - urls
  - userDefined



#>
}


Function CreateContact-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddressMeAs,
        [Parameter()]
        [string]$Addresses,
        [Parameter()]
        [string]$BiographyContentType,
        [Parameter()]
        [string]$BiographyValue,
        [Parameter()]
        [string]$BirthdayDay,
        [Parameter()]
        [string]$BirthdayMonth,
        [Parameter()]
        [string]$BirthdayText,
        [Parameter()]
        [string]$BirthdayYear,
        [Parameter()]
        [string]$CalendarUrls,
        [Parameter()]
        [string]$ClientData,
        [Parameter()]
        [string]$EmailAddresses,
        [Parameter()]
        [string]$Events,
        [Parameter()]
        [string]$ExternalIds,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileAses,
        [Parameter()]
        [string]$GenderValue,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$HonorificPrefix,
        [Parameter()]
        [string]$HonorificSuffix,
        [Parameter()]
        [string]$ImClients,
        [Parameter()]
        [string]$Interests,
        [Parameter()]
        [string]$Locales,
        [Parameter()]
        [string]$Locations,
        [Parameter()]
        [string]$Memberships,
        [Parameter()]
        [string]$MiddleName,
        [Parameter()]
        [string]$MiscKeywords,
        [Parameter()]
        [string]$Nicknames,
        [Parameter()]
        [string]$Occupations,
        [Parameter()]
        [string]$Organizations,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$PhoneNumbers,
        [Parameter()]
        [string]$PhoneticFamilyName,
        [Parameter()]
        [string]$PhoneticFullName,
        [Parameter()]
        [string]$PhoneticGivenName,
        [Parameter()]
        [string]$PhoneticHonorificPrefix,
        [Parameter()]
        [string]$PhoneticHonorificSuffix,
        [Parameter()]
        [string]$PhoneticMiddleName,
        [Parameter()]
        [string]$Relations,
        [Parameter()]
        [string]$SipAddresses,
        [Parameter()]
        [string]$Skills,
        [Parameter()]
        [string]$Sources,
        [Parameter()]
        [string]$UnstructuredName,
        [Parameter()]
        [string]$Urls,
        [Parameter()]
        [string]$UserDefined
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddressMeAs             = @{ OriginalName = '--addressMeAs'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Addresses               = @{ OriginalName = '--addresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BiographyContentType    = @{ OriginalName = '--biographyContentType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BiographyValue          = @{ OriginalName = '--biographyValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayDay             = @{ OriginalName = '--birthdayDay'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayMonth           = @{ OriginalName = '--birthdayMonth'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayText            = @{ OriginalName = '--birthdayText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayYear            = @{ OriginalName = '--birthdayYear'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CalendarUrls            = @{ OriginalName = '--calendarUrls'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ClientData              = @{ OriginalName = '--clientData'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailAddresses          = @{ OriginalName = '--emailAddresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Events                  = @{ OriginalName = '--events'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExternalIds             = @{ OriginalName = '--externalIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName              = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileAses                = @{ OriginalName = '--fileAses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GenderValue             = @{ OriginalName = '--genderValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName               = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HonorificPrefix         = @{ OriginalName = '--honorificPrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HonorificSuffix         = @{ OriginalName = '--honorificSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ImClients               = @{ OriginalName = '--imClients'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Interests               = @{ OriginalName = '--interests'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locales                 = @{ OriginalName = '--locales'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locations               = @{ OriginalName = '--locations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Memberships             = @{ OriginalName = '--memberships'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MiddleName              = @{ OriginalName = '--middleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MiscKeywords            = @{ OriginalName = '--miscKeywords'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Nicknames               = @{ OriginalName = '--nicknames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Occupations             = @{ OriginalName = '--occupations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organizations           = @{ OriginalName = '--organizations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields            = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneNumbers            = @{ OriginalName = '--phoneNumbers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticFamilyName      = @{ OriginalName = '--phoneticFamilyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticFullName        = @{ OriginalName = '--phoneticFullName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticGivenName       = @{ OriginalName = '--phoneticGivenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticHonorificPrefix = @{ OriginalName = '--phoneticHonorificPrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticHonorificSuffix = @{ OriginalName = '--phoneticHonorificSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticMiddleName      = @{ OriginalName = '--phoneticMiddleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Relations               = @{ OriginalName = '--relations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SipAddresses            = @{ OriginalName = '--sipAddresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Skills                  = @{ OriginalName = '--skills'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources                 = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UnstructuredName        = @{ OriginalName = '--unstructuredName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Urls                    = @{ OriginalName = '--urls'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserDefined             = @{ OriginalName = '--userDefined'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "createContact"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Create a new contact and return the person resource for that contact.

.PARAMETER AddressMeAs
The type of pronouns that should be used to address the person.
The value can be custom or one of these predefined values:
  - male
  - female
  - other


.PARAMETER Addresses
A person's physical address.
May be a P.O. box or street address.
All fields are optional.
May be used multiple times in the for of "formattedValue=...;type=...;poBox...", etc.
You may use the following fields:
primary          - True if the field is the primary field; false if the field is a secondary field.
formattedValue   - The unstructured value of the address.
				   If this is not set by the user it will be automatically constructed from structured values.
type             - The type of the address.
                   The type can be custom or one of these predefined values:
                     - home
                     - work
                     - other
poBox            - The P.O. box of the address.
streetAddress    - The street address.
extendedAddress	 - The extended address of the address; for example, the apartment number.
city             - The city of the address.
region           - The region of the address; for example, the state or province.
postalCode	     - The postal code of the address.
country          - The country of the address.
countryCode	     - The ISO 3166-1 alpha-2 country code of the address.


.PARAMETER BiographyContentType
The content type of the biography.
CONTENT_TYPE_UNSPECIFIED  - Unspecified.
TEXT_PLAIN                - Plain text.
TEXT_HTML                 - HTML text.


.PARAMETER BiographyValue
The short biography.


.PARAMETER BirthdayDay
Day of month.
Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.


.PARAMETER BirthdayMonth
Month of year.
Must be from 1 to 12, or 0 if specifying a year without a month and day.


.PARAMETER BirthdayText
A free-form string representing the user's birthday.


.PARAMETER BirthdayYear
Year of date.
Must be from 1 to 9999, or 0 if specifying a date without a year.


.PARAMETER CalendarUrls
The person's calendar URLs.
Can be used multiple times in the form of "url=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
url      - The calendar URL.
type     - The type of the calendar URL.
           The type can be custom or one of these predefined values:
             - home
             - work
             - other


.PARAMETER ClientData
The person's client data.
Arbitrary client data that is populated by clients. Duplicate keys and values are allowed.
Can be used multiple times in the form of "key=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
key      - The client specified key of the client data.
value    - The client specified value of the client data.


.PARAMETER EmailAddresses
The person's email addresses.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary    - True if the field is the primary field; false if the field is a secondary field.
value      - The email address.
type       - The type of the email address.
             The type can be custom or one of these predefined values:
               - home
               - work
               - other
displayName  - The display name of the email.


.PARAMETER Events
The person's events.
Can be used multiple times in the form of "year=...,month=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
year     - Year of date.
           Must be from 1 to 9999, or 0 if specifying a date without a year.
month    - Month of year.
           Must be from 1 to 12, or 0 if specifying a year without a month and day.
day      - Day of month.
           Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
type     - The type of the event.
           The type can be custom or one of these predefined values:
             - anniversary
             - other


.PARAMETER ExternalIds
The person's external IDs.
Can be used multiple times in the form of "value=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The value of the external ID.
type     - The type of the external ID.
           The type can be custom or one of these predefined values:
             - account
             - customer
             - loginId
             - network
             - organization


.PARAMETER FamilyName
The family name.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileAses
The person's file-ases.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The file-as value


.PARAMETER GenderValue
The gender for the person.
The gender can be custom or one of these predefined values:
  - male
  - female
  - unspecified


.PARAMETER GivenName
The given name.


.PARAMETER HonorificPrefix
The honorific prefixes, such as Mrs. or Dr.


.PARAMETER HonorificSuffix
The honorific suffixes, such as Jr.


.PARAMETER ImClients
The person's instant messaging clients.
Can be used multiple times in the form of "primary=...,username=...", etc.
You may use the following fields:
primary   - True if the field is the primary field; false if the field is a secondary field.
username  - The user name used in the IM client.
type      - The type of the IM client.
            The type can be custom or one of these predefined values:
              - home
              - work
			  - other
protocol  - The protocol of the IM client.
            The protocol can be custom or one of these predefined values:
              - aim
              - msn
              - yahoo
              - skype
              - qq
              - googleTalk
              - icq
              - jabber
              - netMeeting


.PARAMETER Interests
The person's interests.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The interest; for example, stargazing.


.PARAMETER Locales
The person's locale preferences.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The well-formed IETF BCP 47 language tag representing the locale.


.PARAMETER Locations
The person's locations.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary       - True if the field is the primary field; false if the field is a secondary field.
value         - The free-form value of the location.
type          - The type of the location.
                The type can be custom or one of these predefined values:
                  - desk
			      - grewUp
current       - Whether the location is the current location.
buildingId    - The building identifier.
floor         - The floor name or number.
floorSection  - The floor section in floor_name.
deskCode      - The individual desk location.


.PARAMETER Memberships
The person's group memberships.
Can be used multiple times in the form of "primary=...,contactGroupResourceName=...", etc.
You may use the following fields:
primary                          - True if the field is the primary field; false if the field is a secondary field.
contactGroupResourceName         - The resource name for the contact group, assigned by the server.
								   An ASCII string, in the form of contactGroups/{contactGroupId}.
								   Only contactGroupResourceName can be used for modifying memberships.
								   Any contact group membership can be removed, but only user group or "myContacts" or "starred" system groups memberships can be added.
								   A contact must always have at least one contact group membership.


.PARAMETER MiddleName
The middle name(s).


.PARAMETER MiscKeywords
The person's miscellaneous keywords.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The value of the miscellaneous keyword.
type     - The miscellaneous keyword type.
           Allowed values are:
             - TYPE_UNSPECIFIED             - Unspecified.
             - OUTLOOK_BILLING_INFORMATION  - Outlook field for billing information.
             - OUTLOOK_DIRECTORY_SERVER     - Outlook field for directory server.
             - OUTLOOK_KEYWORD              - Outlook field for keyword.
             - OUTLOOK_MILEAGE              - Outlook field for mileage.
             - OUTLOOK_PRIORITY             - Outlook field for priority.
             - OUTLOOK_SENSITIVITY          - Outlook field for sensitivity.
             - OUTLOOK_SUBJECT              - Outlook field for subject.
             - OUTLOOK_USER                 - Outlook field for user.
             - HOME                         - Home.
             - WORK                         - Work.
             - OTHER                        - Other.


.PARAMETER Nicknames
The person's nicknames.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The nickname.
type     - The type of a nickname.
           Allowed values are:
			 - DEFAULT         - Generic nickname.
             - ALTERNATE_NAME  - Alternate name person is known by.


.PARAMETER Occupations
The person's occupations.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The occupation; for example, carpenter.


.PARAMETER Organizations
The person's past or current organizations.
Can be used multiple times in the form of "primary=...,type=...", etc.
You may use the following fields:
primary         - True if the field is the primary field; false if the field is a secondary field.
type            - The type of the organization.
                  The type can be custom or one of these predefined values:
                    - work
			        - school
startDateYear   - Year of date.
                  Must be from 1 to 9999, or 0 if specifying a date without a year.
startDateMonth  - Month of year.
                  Must be from 1 to 12, or 0 if specifying a year without a month and day.
startDateDay    - Day of month.
                  Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
endDateYear     - Year of date.
                  Must be from 1 to 9999, or 0 if specifying a date without a year.
endDateMonth    - Month of year.
                  Must be from 1 to 12, or 0 if specifying a year without a month and day.
endDateDay      - Day of month.
                  Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
current         - True if the organization is the person's current organization; false if the organization is a past organization.
name            - The name of the organization.
phoneticName    - The phonetic name of the organization.
department      - The person's department at the organization.
title           - The person's job title at the organization.
jobDescription  - The person's job description at the organization.
symbol          - The symbol associated with the organization; for example, a stock ticker symbol, abbreviation, or acronym.
domain          - The domain name associated with the organization; for example, google.com.
location        - The location of the organization office the person works at.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER PhoneNumbers
The person's phone numbers.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The phone number.
type     - The type of the phone number.
           The type can be custom or one of these predefined values:
             - home
             - work
             - mobile
             - homeFax
             - workFax
             - otherFax
             - pager
             - workMobile
             - workPager
             - main
             - googleVoice
             - other


.PARAMETER PhoneticFamilyName
The family name spelled as it sounds.


.PARAMETER PhoneticFullName
The full name spelled as it sounds.


.PARAMETER PhoneticGivenName
The given name spelled as it sounds.


.PARAMETER PhoneticHonorificPrefix
The honorific prefixes spelled as they sound.


.PARAMETER PhoneticHonorificSuffix
The honorific suffixes spelled as they sound.


.PARAMETER PhoneticMiddleName
The middle name(s) spelled as they sound.


.PARAMETER Relations
The person's relations.
Can be used multiple times in the form of "primary=...,person=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
person   - The name of the other person this relation refers to.
type     - The person's relation to the other person.
           The type can be custom or one of these predefined values:
             - spouse
             - child
             - mother
             - father
             - parent
             - brother
             - sister
             - friend
             - relative
             - domesticPartner
             - manager
             - assistant
             - referredBy
             - partner


.PARAMETER SipAddresses
The person's SIP addresses.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The SIP address in the RFC 3261 19.1 SIP URI format.
type     - The type of the SIP address.
           The type can be custom or or one of these predefined values:
             - home
             - work
             - mobile
             - other


.PARAMETER Skills
The person's skills.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The skill; for example, underwater basket weaving.


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.


.PARAMETER UnstructuredName
The free form name value.


.PARAMETER Urls
The person's associated URLs.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The URL.
type     - The type of the URL.
           The type can be custom or one of these predefined values:
             - home
             - work
             - blog
             - profile
             - homePage
             - ftp
             - reservations
             - appInstallPage: website for a Currents application.
             - other


.PARAMETER UserDefined
The person's user defined data.
Can be used multiple times in the form of "primary=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
key      - The end user specified key of the user defined data.
value    - The end user specified value of the user defined data.



#>
}


Function DeleteContact-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ResourceName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "deleteContact"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a contact person. Any non-contact data will not be deleted.

.PARAMETER ResourceName
The resource name of the contact-



#>
}


Function DeleteContactPhoto-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "deleteContactPhoto"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a contact's photo.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER ResourceName
The resource name of the contact-


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function Get-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Provides information about a person by specifying a resource name.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER ResourceName
The resource name of the contact-


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function GetBatchGet-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$ResourceNames,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields        = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields  = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceNames = @{ OriginalName = '--resourceNames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources       = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "getBatchGet"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Provides information about a list of specific people by specifying a list of requested resource names.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER ResourceNames
The resource names of the people to provide information about.
It's repeatable. The URL query parameter should be

resourceNames=<name1>&resourceNames=<name2>&...

To get information about the authenticated user, specify people/me.
To get information about a google account, specify people/{account_id}.
To get information about a contact, specify the resource name that identifies the contact as returned by people.connections.list.
You can include up to 50 resource names in one request.


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function List-People {


    [CmdletBinding()]

    param(    )

    BEGIN {
        $__PARAMETERMAP = @{}
        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Provides a list of the authenticated user's contacts.

#>
}


Function ListDirectoryPeople-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MergeSources,
        [Parameter()]
        [string]$ReadMask,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MergeSources = @{ OriginalName = '--mergeSources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadMask     = @{ OriginalName = '--readMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "listDirectoryPeople"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a contact person. Any non-contact data will not be deleted.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MergeSources
Additional data to merge into the directory sources if they are connected through verified join keys such as email addresses or phone numbers.


.PARAMETER ReadMask
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function SearchDirectoryPeople-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$MergeSources,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [string]$ReadMask,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MergeSources = @{ OriginalName = '--mergeSources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query        = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReadMask     = @{ OriginalName = '--readMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "searchDirectoryPeople"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a contact person. Any non-contact data will not be deleted.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER MergeSources
Additional data to merge into the directory sources if they are connected through verified join keys such as email addresses or phone numbers.


.PARAMETER Query
Prefix query that matches fields in the person.
Does NOT use the readMask for determining what fields to match.


.PARAMETER ReadMask
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function UpdateContact-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddressMeAs,
        [Parameter()]
        [string]$Addresses,
        [Parameter()]
        [string]$BiographyContentType,
        [Parameter()]
        [string]$BiographyValue,
        [Parameter()]
        [string]$BirthdayDay,
        [Parameter()]
        [string]$BirthdayMonth,
        [Parameter()]
        [string]$BirthdayText,
        [Parameter()]
        [string]$BirthdayYear,
        [Parameter()]
        [string]$CalendarUrls,
        [Parameter()]
        [string]$ClientData,
        [Parameter()]
        [string]$EmailAddresses,
        [Parameter()]
        [string]$Events,
        [Parameter()]
        [string]$ExternalIds,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileAses,
        [Parameter()]
        [string]$GenderValue,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$HonorificPrefix,
        [Parameter()]
        [string]$HonorificSuffix,
        [Parameter()]
        [string]$ImClients,
        [Parameter()]
        [string]$Interests,
        [Parameter()]
        [string]$Locales,
        [Parameter()]
        [string]$Locations,
        [Parameter()]
        [string]$Memberships,
        [Parameter()]
        [string]$MiddleName,
        [Parameter()]
        [string]$MiscKeywords,
        [Parameter()]
        [string]$Nicknames,
        [Parameter()]
        [string]$Occupations,
        [Parameter()]
        [string]$Organizations,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$PhoneNumbers,
        [Parameter()]
        [string]$PhoneticFamilyName,
        [Parameter()]
        [string]$PhoneticFullName,
        [Parameter()]
        [string]$PhoneticGivenName,
        [Parameter()]
        [string]$PhoneticHonorificPrefix,
        [Parameter()]
        [string]$PhoneticHonorificSuffix,
        [Parameter()]
        [string]$PhoneticMiddleName,
        [Parameter()]
        [string]$Relations,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$SipAddresses,
        [Parameter()]
        [string]$Skills,
        [Parameter()]
        [string]$Sources,
        [Parameter()]
        [string]$UnstructuredName,
        [Parameter()]
        [string]$UpdatePersonFields,
        [Parameter()]
        [string]$Urls,
        [Parameter()]
        [string]$UserDefined
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddressMeAs             = @{ OriginalName = '--addressMeAs'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Addresses               = @{ OriginalName = '--addresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BiographyContentType    = @{ OriginalName = '--biographyContentType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BiographyValue          = @{ OriginalName = '--biographyValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayDay             = @{ OriginalName = '--birthdayDay'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayMonth           = @{ OriginalName = '--birthdayMonth'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayText            = @{ OriginalName = '--birthdayText'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BirthdayYear            = @{ OriginalName = '--birthdayYear'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CalendarUrls            = @{ OriginalName = '--calendarUrls'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ClientData              = @{ OriginalName = '--clientData'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailAddresses          = @{ OriginalName = '--emailAddresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Events                  = @{ OriginalName = '--events'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExternalIds             = @{ OriginalName = '--externalIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName              = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileAses                = @{ OriginalName = '--fileAses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GenderValue             = @{ OriginalName = '--genderValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName               = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HonorificPrefix         = @{ OriginalName = '--honorificPrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HonorificSuffix         = @{ OriginalName = '--honorificSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ImClients               = @{ OriginalName = '--imClients'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Interests               = @{ OriginalName = '--interests'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locales                 = @{ OriginalName = '--locales'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locations               = @{ OriginalName = '--locations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Memberships             = @{ OriginalName = '--memberships'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MiddleName              = @{ OriginalName = '--middleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MiscKeywords            = @{ OriginalName = '--miscKeywords'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Nicknames               = @{ OriginalName = '--nicknames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Occupations             = @{ OriginalName = '--occupations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organizations           = @{ OriginalName = '--organizations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields            = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneNumbers            = @{ OriginalName = '--phoneNumbers'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticFamilyName      = @{ OriginalName = '--phoneticFamilyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticFullName        = @{ OriginalName = '--phoneticFullName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticGivenName       = @{ OriginalName = '--phoneticGivenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticHonorificPrefix = @{ OriginalName = '--phoneticHonorificPrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticHonorificSuffix = @{ OriginalName = '--phoneticHonorificSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneticMiddleName      = @{ OriginalName = '--phoneticMiddleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Relations               = @{ OriginalName = '--relations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName            = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SipAddresses            = @{ OriginalName = '--sipAddresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Skills                  = @{ OriginalName = '--skills'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources                 = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UnstructuredName        = @{ OriginalName = '--unstructuredName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UpdatePersonFields      = @{ OriginalName = '--updatePersonFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Urls                    = @{ OriginalName = '--urls'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserDefined             = @{ OriginalName = '--userDefined'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "updateContact"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Update contact data for an existing contact person.

.PARAMETER AddressMeAs
The type of pronouns that should be used to address the person.
The value can be custom or one of these predefined values:
  - male
  - female
  - other


.PARAMETER Addresses
A person's physical address.
May be a P.O. box or street address.
All fields are optional.
May be used multiple times in the for of "formattedValue=...;type=...;poBox...", etc.
You may use the following fields:
primary          - True if the field is the primary field; false if the field is a secondary field.
formattedValue   - The unstructured value of the address.
				   If this is not set by the user it will be automatically constructed from structured values.
type             - The type of the address.
                   The type can be custom or one of these predefined values:
                     - home
                     - work
                     - other
poBox            - The P.O. box of the address.
streetAddress    - The street address.
extendedAddress	 - The extended address of the address; for example, the apartment number.
city             - The city of the address.
region           - The region of the address; for example, the state or province.
postalCode	     - The postal code of the address.
country          - The country of the address.
countryCode	     - The ISO 3166-1 alpha-2 country code of the address.


.PARAMETER BiographyContentType
The content type of the biography.
CONTENT_TYPE_UNSPECIFIED  - Unspecified.
TEXT_PLAIN                - Plain text.
TEXT_HTML                 - HTML text.


.PARAMETER BiographyValue
The short biography.


.PARAMETER BirthdayDay
Day of month.
Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.


.PARAMETER BirthdayMonth
Month of year.
Must be from 1 to 12, or 0 if specifying a year without a month and day.


.PARAMETER BirthdayText
A free-form string representing the user's birthday.


.PARAMETER BirthdayYear
Year of date.
Must be from 1 to 9999, or 0 if specifying a date without a year.


.PARAMETER CalendarUrls
The person's calendar URLs.
Can be used multiple times in the form of "url=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
url      - The calendar URL.
type     - The type of the calendar URL.
           The type can be custom or one of these predefined values:
             - home
             - work
             - other


.PARAMETER ClientData
The person's client data.
Arbitrary client data that is populated by clients. Duplicate keys and values are allowed.
Can be used multiple times in the form of "key=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
key      - The client specified key of the client data.
value    - The client specified value of the client data.


.PARAMETER EmailAddresses
The person's email addresses.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary    - True if the field is the primary field; false if the field is a secondary field.
value      - The email address.
type       - The type of the email address.
             The type can be custom or one of these predefined values:
               - home
               - work
               - other
displayName  - The display name of the email.


.PARAMETER Events
The person's events.
Can be used multiple times in the form of "year=...,month=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
year     - Year of date.
           Must be from 1 to 9999, or 0 if specifying a date without a year.
month    - Month of year.
           Must be from 1 to 12, or 0 if specifying a year without a month and day.
day      - Day of month.
           Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
type     - The type of the event.
           The type can be custom or one of these predefined values:
             - anniversary
             - other


.PARAMETER ExternalIds
The person's external IDs.
Can be used multiple times in the form of "value=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The value of the external ID.
type     - The type of the external ID.
           The type can be custom or one of these predefined values:
             - account
             - customer
             - loginId
             - network
             - organization


.PARAMETER FamilyName
The family name.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileAses
The person's file-ases.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The file-as value


.PARAMETER GenderValue
The gender for the person.
The gender can be custom or one of these predefined values:
  - male
  - female
  - unspecified


.PARAMETER GivenName
The given name.


.PARAMETER HonorificPrefix
The honorific prefixes, such as Mrs. or Dr.


.PARAMETER HonorificSuffix
The honorific suffixes, such as Jr.


.PARAMETER ImClients
The person's instant messaging clients.
Can be used multiple times in the form of "primary=...,username=...", etc.
You may use the following fields:
primary   - True if the field is the primary field; false if the field is a secondary field.
username  - The user name used in the IM client.
type      - The type of the IM client.
            The type can be custom or one of these predefined values:
              - home
              - work
			  - other
protocol  - The protocol of the IM client.
            The protocol can be custom or one of these predefined values:
              - aim
              - msn
              - yahoo
              - skype
              - qq
              - googleTalk
              - icq
              - jabber
              - netMeeting


.PARAMETER Interests
The person's interests.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The interest; for example, stargazing.


.PARAMETER Locales
The person's locale preferences.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The well-formed IETF BCP 47 language tag representing the locale.


.PARAMETER Locations
The person's locations.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary       - True if the field is the primary field; false if the field is a secondary field.
value         - The free-form value of the location.
type          - The type of the location.
                The type can be custom or one of these predefined values:
                  - desk
			      - grewUp
current       - Whether the location is the current location.
buildingId    - The building identifier.
floor         - The floor name or number.
floorSection  - The floor section in floor_name.
deskCode      - The individual desk location.


.PARAMETER Memberships
The person's group memberships.
Can be used multiple times in the form of "primary=...,contactGroupResourceName=...", etc.
You may use the following fields:
primary                          - True if the field is the primary field; false if the field is a secondary field.
contactGroupResourceName         - The resource name for the contact group, assigned by the server.
								   An ASCII string, in the form of contactGroups/{contactGroupId}.
								   Only contactGroupResourceName can be used for modifying memberships.
								   Any contact group membership can be removed, but only user group or "myContacts" or "starred" system groups memberships can be added.
								   A contact must always have at least one contact group membership.


.PARAMETER MiddleName
The middle name(s).


.PARAMETER MiscKeywords
The person's miscellaneous keywords.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The value of the miscellaneous keyword.
type     - The miscellaneous keyword type.
           Allowed values are:
             - TYPE_UNSPECIFIED             - Unspecified.
             - OUTLOOK_BILLING_INFORMATION  - Outlook field for billing information.
             - OUTLOOK_DIRECTORY_SERVER     - Outlook field for directory server.
             - OUTLOOK_KEYWORD              - Outlook field for keyword.
             - OUTLOOK_MILEAGE              - Outlook field for mileage.
             - OUTLOOK_PRIORITY             - Outlook field for priority.
             - OUTLOOK_SENSITIVITY          - Outlook field for sensitivity.
             - OUTLOOK_SUBJECT              - Outlook field for subject.
             - OUTLOOK_USER                 - Outlook field for user.
             - HOME                         - Home.
             - WORK                         - Work.
             - OTHER                        - Other.


.PARAMETER Nicknames
The person's nicknames.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The nickname.
type     - The type of a nickname.
           Allowed values are:
			 - DEFAULT         - Generic nickname.
             - ALTERNATE_NAME  - Alternate name person is known by.


.PARAMETER Occupations
The person's occupations.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The occupation; for example, carpenter.


.PARAMETER Organizations
The person's past or current organizations.
Can be used multiple times in the form of "primary=...,type=...", etc.
You may use the following fields:
primary         - True if the field is the primary field; false if the field is a secondary field.
type            - The type of the organization.
                  The type can be custom or one of these predefined values:
                    - work
			        - school
startDateYear   - Year of date.
                  Must be from 1 to 9999, or 0 if specifying a date without a year.
startDateMonth  - Month of year.
                  Must be from 1 to 12, or 0 if specifying a year without a month and day.
startDateDay    - Day of month.
                  Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
endDateYear     - Year of date.
                  Must be from 1 to 9999, or 0 if specifying a date without a year.
endDateMonth    - Month of year.
                  Must be from 1 to 12, or 0 if specifying a year without a month and day.
endDateDay      - Day of month.
                  Must be from 1 to 31 and valid for the year and month, or 0 if specifying a year by itself or a year and month where the day is not significant.
current         - True if the organization is the person's current organization; false if the organization is a past organization.
name            - The name of the organization.
phoneticName    - The phonetic name of the organization.
department      - The person's department at the organization.
title           - The person's job title at the organization.
jobDescription  - The person's job description at the organization.
symbol          - The symbol associated with the organization; for example, a stock ticker symbol, abbreviation, or acronym.
domain          - The domain name associated with the organization; for example, google.com.
location        - The location of the organization office the person works at.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER PhoneNumbers
The person's phone numbers.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The phone number.
type     - The type of the phone number.
           The type can be custom or one of these predefined values:
             - home
             - work
             - mobile
             - homeFax
             - workFax
             - otherFax
             - pager
             - workMobile
             - workPager
             - main
             - googleVoice
             - other


.PARAMETER PhoneticFamilyName
The family name spelled as it sounds.


.PARAMETER PhoneticFullName
The full name spelled as it sounds.


.PARAMETER PhoneticGivenName
The given name spelled as it sounds.


.PARAMETER PhoneticHonorificPrefix
The honorific prefixes spelled as they sound.


.PARAMETER PhoneticHonorificSuffix
The honorific suffixes spelled as they sound.


.PARAMETER PhoneticMiddleName
The middle name(s) spelled as they sound.


.PARAMETER Relations
The person's relations.
Can be used multiple times in the form of "primary=...,person=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
person   - The name of the other person this relation refers to.
type     - The person's relation to the other person.
           The type can be custom or one of these predefined values:
             - spouse
             - child
             - mother
             - father
             - parent
             - brother
             - sister
             - friend
             - relative
             - domesticPartner
             - manager
             - assistant
             - referredBy
             - partner


.PARAMETER ResourceName
The resource name of the contact-


.PARAMETER SipAddresses
The person's SIP addresses.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The SIP address in the RFC 3261 19.1 SIP URI format.
type     - The type of the SIP address.
           The type can be custom or or one of these predefined values:
             - home
             - work
             - mobile
             - other


.PARAMETER Skills
The person's skills.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The skill; for example, underwater basket weaving.


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.


.PARAMETER UnstructuredName
The free form name value.


.PARAMETER UpdatePersonFields
A field mask to restrict which fields on the person are updated.
Multiple fields can be specified by separating them with commas.
All updated fields will be replaced.
Valid values are:
addresses
biographies
birthdays
calendarUrls
clientData
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
relations
sipAddresses
urls
userDefined


.PARAMETER Urls
The person's associated URLs.
Can be used multiple times in the form of "primary=...,value=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
value    - The URL.
type     - The type of the URL.
           The type can be custom or one of these predefined values:
             - home
             - work
             - blog
             - profile
             - homePage
             - ftp
             - reservations
             - appInstallPage: website for a Currents application.
             - other


.PARAMETER UserDefined
The person's user defined data.
Can be used multiple times in the form of "primary=...,type=...", etc.
You may use the following fields:
primary  - True if the field is the primary field; false if the field is a secondary field.
key      - The end user specified key of the user defined data.
value    - The end user specified value of the user defined data.



#>
}


Function UpdateContactPhoto-People {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$PersonFields,
        [Parameter()]
        [string]$Photo,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$Sources
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PersonFields = @{ OriginalName = '--personFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Photo        = @{ OriginalName = '--photo'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sources      = @{ OriginalName = '--sources'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "people"
            "updateContactPhoto"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Update contact data for an existing contact person.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER PersonFields
A field mask to restrict which fields on each person are returned.
Multiple fields can be specified by separating them with commas.
Defaults to all fields if not set.
Valid values are:
addresses
ageRanges
biographies
birthdays
calendarUrls
clientData
coverPhotos
emailAddresses
events
externalIds
genders
imClients
interests
locales
locations
memberships
metadata
miscKeywords
names
nicknames
occupations
organizations
phoneNumbers
photos
relations
sipAddresses
skills
urls
userDefined


.PARAMETER Photo
Path to a photo file.


.PARAMETER ResourceName
The resource name of the contact-


.PARAMETER Sources
A mask of what source types to return.
DIRECTORY_SOURCE_TYPE_DOMAIN_CONTACT  - Workspace domain shared contact.
DIRECTORY_SOURCE_TYPE_DOMAIN_PROFILE  - Workspace domain profile.
READ_SOURCE_TYPE_PROFILE              - Returns SourceType.ACCOUNT, SourceType.DOMAIN_PROFILE, and SourceType.PROFILE.
READ_SOURCE_TYPE_CONTACT              - Returns SourceType.CONTACT.
READ_SOURCE_TYPE_DOMAIN_CONTACT       - Returns SourceType.DOMAIN_CONTACT.



#>
}


Function Create-Permissions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AllowFileDiscovery,
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$EmailAddress,
        [Parameter()]
        [string]$EmailMessage,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [switch]$MoveToNewOwnersRoot,
        [Parameter()]
        [string]$Role,
        [Parameter()]
        [switch]$SendNotificationEmail,
        [Parameter()]
        [switch]$TransferOwnership,
        [Parameter()]
        [string]$Type,
        [Parameter()]
        [switch]$UseDomainAdminAccess,
        [Parameter()]
        [string]$View
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AllowFileDiscovery    = @{ OriginalName = '--allowFileDiscovery'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Domain                = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailAddress          = @{ OriginalName = '--emailAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailMessage          = @{ OriginalName = '--emailMessage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MoveToNewOwnersRoot   = @{ OriginalName = '--moveToNewOwnersRoot'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Role                  = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendNotificationEmail = @{ OriginalName = '--sendNotificationEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            TransferOwnership     = @{ OriginalName = '--transferOwnership'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Type                  = @{ OriginalName = '--type'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess  = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            View                  = @{ OriginalName = '--view'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "permissions"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a permission for a file or shared drive.

.PARAMETER AllowFileDiscovery
Whether the permission allows the file to be discovered through search.
This is only applicable for permissions of type domain or anyone.


.PARAMETER Domain
The domain to which this permission refers.


.PARAMETER EmailAddress
The email address of the user or group to which this permission refers.


.PARAMETER EmailMessage
A plain text custom message to include in the notification email


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
Id of the file or drive


.PARAMETER MoveToNewOwnersRoot
This parameter only takes effect if the item is not in a shared drive and the request is attempting to transfer the ownership of the item.
When set to true, the item is moved to the new owner's My Drive root folder and all prior parents removed.
however, the file will be added to the new owner's My Drive root folder, unless it is already in the new owner's My Drive.


.PARAMETER Role
"The role granted by this permission.
While new values may be supported in the future, the following are currently allowed:
[owner|organizer|fileOrganizer|writer|commenter|reader]"


.PARAMETER SendNotificationEmail
Whether to send a notification email when sharing to users or groups.
This defaults to true for users and groups, and is not allowed for other requests.
It must not be disabled for ownership transfers.


.PARAMETER TransferOwnership
Whether to transfer ownership to the specified user and downgrade the current owner to a writer.
This parameter is required as an acknowledgement of the side effect.


.PARAMETER Type
The type of the grantee.
[user|group|domain|anyone].
When creating a permission, if type is user or group, you must provide an emailAddress for the user or group.
When type is domain, you must provide a domain.
There isn't extra information required for a anyone type.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.


.PARAMETER View
Indicates the view for this permission.
Only populated for permissions that belong to a view. published is the only supported value.



#>
}


Function Delete-Permissions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$PermissionId,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            FileId               = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PermissionId         = @{ OriginalName = '--permissionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "permissions"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a permission.

.PARAMETER FileId
Id of the file or drive


.PARAMETER PermissionId
The ID of the permission.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.



#>
}


Function Get-Permissions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$PermissionId,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId               = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PermissionId         = @{ OriginalName = '--permissionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "permissions"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a permission by ID.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
Id of the file or drive


.PARAMETER PermissionId
The ID of the permission.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.



#>
}


Function List-Permissions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$IncludePermissionsForView,
        [Parameter()]
        [switch]$UseDomainAdminAccess
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields                    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludePermissionsForView = @{ OriginalName = '--includePermissionsForView'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess      = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "permissions"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists a file's or shared drive's permissions.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
Id of the file or drive


.PARAMETER IncludePermissionsForView
Specifies which additional view's permissions to include in the response.
Only 'published' is supported.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.



#>
}


Function Update-Permissions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AllowFileDiscovery,
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$EmailMessage,
        [Parameter()]
        [string]$ExpirationTime,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [switch]$MoveToNewOwnersRoot,
        [Parameter()]
        [string]$PermissionId,
        [Parameter()]
        [switch]$RemoveExpiration,
        [Parameter()]
        [string]$Role,
        [Parameter()]
        [switch]$SendNotificationEmail,
        [Parameter()]
        [switch]$TransferOwnership,
        [Parameter()]
        [string]$Type,
        [Parameter()]
        [switch]$UseDomainAdminAccess,
        [Parameter()]
        [string]$View
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AllowFileDiscovery    = @{ OriginalName = '--allowFileDiscovery'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Domain                = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            EmailMessage          = @{ OriginalName = '--emailMessage'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExpirationTime        = @{ OriginalName = '--expirationTime'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MoveToNewOwnersRoot   = @{ OriginalName = '--moveToNewOwnersRoot'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            PermissionId          = @{ OriginalName = '--permissionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RemoveExpiration      = @{ OriginalName = '--removeExpiration'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Role                  = @{ OriginalName = '--role'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendNotificationEmail = @{ OriginalName = '--sendNotificationEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            TransferOwnership     = @{ OriginalName = '--transferOwnership'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Type                  = @{ OriginalName = '--type'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UseDomainAdminAccess  = @{ OriginalName = '--useDomainAdminAccess'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            View                  = @{ OriginalName = '--view'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "permissions"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a permission with patch semantics.

.PARAMETER AllowFileDiscovery
Whether the permission allows the file to be discovered through search.
This is only applicable for permissions of type domain or anyone.


.PARAMETER Domain
The domain to which this permission refers.


.PARAMETER EmailMessage
A plain text custom message to include in the notification email


.PARAMETER ExpirationTime
The time at which this permission will expire (RFC 3339 date-time). Expiration times have the following restrictions:
They can only be set on user and group permissions
The time must be in the future
The time cannot be more than a year in the future


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
Id of the file or drive


.PARAMETER MoveToNewOwnersRoot
This parameter only takes effect if the item is not in a shared drive and the request is attempting to transfer the ownership of the item.
When set to true, the item is moved to the new owner's My Drive root folder and all prior parents removed.
however, the file will be added to the new owner's My Drive root folder, unless it is already in the new owner's My Drive.


.PARAMETER PermissionId
The ID of the permission.


.PARAMETER RemoveExpiration
Whether to remove the expiration date.


.PARAMETER Role
"The role granted by this permission.
While new values may be supported in the future, the following are currently allowed:
[owner|organizer|fileOrganizer|writer|commenter|reader]"


.PARAMETER SendNotificationEmail
Whether to send a notification email when sharing to users or groups.
This defaults to true for users and groups, and is not allowed for other requests.
It must not be disabled for ownership transfers.


.PARAMETER TransferOwnership
Whether to transfer ownership to the specified user and downgrade the current owner to a writer.
This parameter is required as an acknowledgement of the side effect.


.PARAMETER Type
The type of the grantee.
[user|group|domain|anyone].
When creating a permission, if type is user or group, you must provide an emailAddress for the user or group.
When type is domain, you must provide a domain.
There isn't extra information required for a anyone type.


.PARAMETER UseDomainAdminAccess
Issue the request as a domain administrator; if set to true, then the requester will be granted access if the file ID parameter refers to a shared drive and the requester is an administrator of the domain to which the shared drive belongs.


.PARAMETER View
Indicates the view for this permission.
Only populated for permissions that belong to a view. published is the only supported value.



#>
}


Function List-Privileges {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "privileges"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of all privileges for a customer.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Create-Replies {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Action,
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Content,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Action    = @{ OriginalName = '--action'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Content   = @{ OriginalName = '--content'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "replies"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a new reply to a comment.

.PARAMETER Action
The action the reply performed to the parent comment.
[resolve|reopen]


.PARAMETER CommentId
The ID of the comment.


.PARAMETER Content
The plain text content of the comment.
This field is used for setting the content, while htmlContent should be displayed.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.



#>
}


Function Delete-Replies {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$ReplyId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyId   = @{ OriginalName = '--replyId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "replies"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a reply.

.PARAMETER CommentId
The ID of the comment.


.PARAMETER FileId
The ID of the file.


.PARAMETER ReplyId
The ID of the reply.



#>
}


Function Get-Replies {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$ReplyId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyId   = @{ OriginalName = '--replyId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "replies"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a reply by ID.

.PARAMETER CommentId
The ID of the comment.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER ReplyId
The ID of the reply.



#>
}


Function List-Replies {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "replies"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists a comment's replies.

.PARAMETER CommentId
The ID of the comment.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.



#>
}


Function Update-Replies {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Action,
        [Parameter()]
        [string]$CommentId,
        [Parameter()]
        [string]$Content,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$ReplyId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Action    = @{ OriginalName = '--action'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CommentId = @{ OriginalName = '--commentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Content   = @{ OriginalName = '--content'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields    = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId    = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyId   = @{ OriginalName = '--replyId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "replies"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a reply with patch semantics.

.PARAMETER Action
The action the reply performed to the parent comment.
[resolve|reopen]


.PARAMETER CommentId
The ID of the comment.


.PARAMETER Content
The plain text content of the comment.
This field is used for setting the content, while htmlContent should be displayed.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER ReplyId
The ID of the reply.



#>
}


Function Delete-ResourcesBuildings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$Customer
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BuildingId = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesBuildings"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a building.

.PARAMETER BuildingId
The ID of the file.


.PARAMETER Customer
The unique ID for the customer's Workspace account. As an account administrator, you can also use the my_customer alias to represent your account's customer ID.



#>
}


Function Get-ResourcesBuildings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BuildingId = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesBuildings"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a building.

.PARAMETER BuildingId
The ID of the file.


.PARAMETER Customer
The unique ID for the customer's Workspace account. As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-ResourcesBuildings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddressLines,
        [Parameter()]
        [string]$AdministrativeArea,
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$BuildingName,
        [Parameter()]
        [string]$CoordinatesSource,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FloorNames,
        [Parameter()]
        [string]$LanguageCode,
        [Parameter()]
        [string]$Latitude,
        [Parameter()]
        [string]$Locality,
        [Parameter()]
        [string]$Longitude,
        [Parameter()]
        [string]$PostalCode,
        [Parameter()]
        [string]$RegionCode,
        [Parameter()]
        [string]$Sublocality
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddressLines       = @{ OriginalName = '--addressLines'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AdministrativeArea = @{ OriginalName = '--administrativeArea'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BuildingId         = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BuildingName       = @{ OriginalName = '--buildingName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CoordinatesSource  = @{ OriginalName = '--coordinatesSource'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer           = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description        = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorNames         = @{ OriginalName = '--floorNames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            LanguageCode       = @{ OriginalName = '--languageCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Latitude           = @{ OriginalName = '--latitude'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locality           = @{ OriginalName = '--locality'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Longitude          = @{ OriginalName = '--longitude'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PostalCode         = @{ OriginalName = '--postalCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RegionCode         = @{ OriginalName = '--regionCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sublocality        = @{ OriginalName = '--sublocality'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesBuildings"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts a building.

.PARAMETER AddressLines
Unstructured address lines describing the lower levels of an address.


.PARAMETER AdministrativeArea
Optional. Highest administrative subdivision which is used for postal addresses of a country or region.


.PARAMETER BuildingId
The ID of the file.


.PARAMETER BuildingName
The building name as seen by users in Calendar.
Must be unique for the customer. For example, "NYC-CHEL".
The maximum length is 100 characters.


.PARAMETER CoordinatesSource
Source from which Building.coordinates are derived.

Acceptable values are:
CLIENT_SPECIFIED       - Building.coordinates are set to the coordinates included in the request.
RESOLVED_FROM_ADDRESS  - Building.coordinates are automatically populated based on the postal address.
SOURCE_UNSPECIFIED     - Defaults to RESOLVED_FROM_ADDRESS if postal address is provided. Otherwise, defaults to CLIENT_SPECIFIED if coordinates are provided. (default)


.PARAMETER Customer
The unique ID for the customer's Workspace account. As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Description
A brief description of the building. For example, "Chelsea Market".


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FloorNames
The display names for all floors in this building.
The floors are expected to be sorted in ascending order, from lowest floor to highest floor.
For example, ["B2", "B1", "L", "1", "2", "2M", "3", "PH"] Must contain at least one entry.


.PARAMETER LanguageCode
Optional. BCP-47 language code of the contents of this address (if known).


.PARAMETER Latitude
Latitude in decimal degrees.


.PARAMETER Locality
Optional. Generally refers to the city/town portion of the address.
Examples: US city, IT comune, UK post town.
In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.


.PARAMETER Longitude
Longitude in decimal degrees.


.PARAMETER PostalCode
Optional. Postal code of the address.


.PARAMETER RegionCode
Required. CLDR region code of the country/region of the address.


.PARAMETER Sublocality
Optional. Sublocality of the address.



#>
}


Function List-ResourcesBuildings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesBuildings"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a list of buildings for an account.

.PARAMETER Customer
The unique ID for the customer's Workspace account. As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-ResourcesBuildings {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddressLines,
        [Parameter()]
        [string]$AdministrativeArea,
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$BuildingName,
        [Parameter()]
        [string]$CoordinatesSource,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Description,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FloorNames,
        [Parameter()]
        [string]$LanguageCode,
        [Parameter()]
        [string]$Latitude,
        [Parameter()]
        [string]$Locality,
        [Parameter()]
        [string]$Longitude,
        [Parameter()]
        [string]$PostalCode,
        [Parameter()]
        [string]$RegionCode,
        [Parameter()]
        [string]$Sublocality
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddressLines       = @{ OriginalName = '--addressLines'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            AdministrativeArea = @{ OriginalName = '--administrativeArea'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BuildingId         = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            BuildingName       = @{ OriginalName = '--buildingName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CoordinatesSource  = @{ OriginalName = '--coordinatesSource'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer           = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Description        = @{ OriginalName = '--description'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorNames         = @{ OriginalName = '--floorNames'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            LanguageCode       = @{ OriginalName = '--languageCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Latitude           = @{ OriginalName = '--latitude'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locality           = @{ OriginalName = '--locality'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Longitude          = @{ OriginalName = '--longitude'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PostalCode         = @{ OriginalName = '--postalCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RegionCode         = @{ OriginalName = '--regionCode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Sublocality        = @{ OriginalName = '--sublocality'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesBuildings"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a building. This method supports patch semantics. 

.PARAMETER AddressLines
Unstructured address lines describing the lower levels of an address.


.PARAMETER AdministrativeArea
Optional. Highest administrative subdivision which is used for postal addresses of a country or region.


.PARAMETER BuildingId
The ID of the file.


.PARAMETER BuildingName
The building name as seen by users in Calendar.
Must be unique for the customer. For example, "NYC-CHEL".
The maximum length is 100 characters.


.PARAMETER CoordinatesSource
Source from which Building.coordinates are derived.

Acceptable values are:
CLIENT_SPECIFIED       - Building.coordinates are set to the coordinates included in the request.
RESOLVED_FROM_ADDRESS  - Building.coordinates are automatically populated based on the postal address.
SOURCE_UNSPECIFIED     - Defaults to RESOLVED_FROM_ADDRESS if postal address is provided. Otherwise, defaults to CLIENT_SPECIFIED if coordinates are provided. (default)


.PARAMETER Customer
The unique ID for the customer's Workspace account. As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Description
A brief description of the building. For example, "Chelsea Market".


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FloorNames
The display names for all floors in this building.
The floors are expected to be sorted in ascending order, from lowest floor to highest floor.
For example, ["B2", "B1", "L", "1", "2", "2M", "3", "PH"] Must contain at least one entry.


.PARAMETER LanguageCode
Optional. BCP-47 language code of the contents of this address (if known).


.PARAMETER Latitude
Latitude in decimal degrees.


.PARAMETER Locality
Optional. Generally refers to the city/town portion of the address.
Examples: US city, IT comune, UK post town.
In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use addressLines.


.PARAMETER Longitude
Longitude in decimal degrees.


.PARAMETER PostalCode
Optional. Postal code of the address.


.PARAMETER RegionCode
Required. CLDR region code of the country/region of the address.


.PARAMETER Sublocality
Optional. Sublocality of the address.



#>
}


Function Delete-ResourcesCalendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarResourceId,
        [Parameter()]
        [string]$Customer
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarResourceId = @{ OriginalName = '--calendarResourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer           = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesCalendars"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a calendar resource.

.PARAMETER CalendarResourceId
The unique ID of the calendar resource


.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.



#>
}


Function Get-ResourcesCalendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CalendarResourceId,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CalendarResourceId = @{ OriginalName = '--calendarResourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer           = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields             = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesCalendars"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a calendar resource.

.PARAMETER CalendarResourceId
The unique ID of the calendar resource


.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-ResourcesCalendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$Capacity,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$FeatureInstances,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FloorName,
        [Parameter()]
        [string]$FloorSection,
        [Parameter()]
        [string]$ResourceCategory,
        [Parameter()]
        [string]$ResourceDescription,
        [Parameter()]
        [string]$ResourceId,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$ResourceType,
        [Parameter()]
        [string]$UserVisibleDescription
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BuildingId             = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Capacity               = @{ OriginalName = '--capacity'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer               = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FeatureInstances       = @{ OriginalName = '--featureInstances'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                 = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorName              = @{ OriginalName = '--floorName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorSection           = @{ OriginalName = '--floorSection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceCategory       = @{ OriginalName = '--resourceCategory'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceDescription    = @{ OriginalName = '--resourceDescription'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceId             = @{ OriginalName = '--resourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName           = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceType           = @{ OriginalName = '--resourceType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserVisibleDescription = @{ OriginalName = '--userVisibleDescription'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesCalendars"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts a calendar resource.

.PARAMETER BuildingId
Unique ID for the building a resource is located in.


.PARAMETER Capacity
Capacity of a resource, number of seats in a room.


.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER FeatureInstances
Instances of features for the calendar resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FloorName
Name of the floor a resource is located on.


.PARAMETER FloorSection
Name of the section within a floor a resource is located in.


.PARAMETER ResourceCategory
The category of the calendar resource. Either CONFERENCE_ROOM or OTHER. Legacy data is set to CATEGORY_UNKNOWN.

Acceptable values are:
CATEGORY_UNKNOWN
CONFERENCE_ROOM
OTHER


.PARAMETER ResourceDescription
Description of the resource, visible only to admins.


.PARAMETER ResourceId
The unique ID of the calendar resource


.PARAMETER ResourceName
The name of the calendar resource. For example, "Training Room 1A".


.PARAMETER ResourceType
The type of the calendar resource, intended for non-room resources.


.PARAMETER UserVisibleDescription
Description of the resource, visible to users and admins.



#>
}


Function List-ResourcesCalendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$Query
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy  = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query    = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesCalendars"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a list of calendar resources for an account.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrderBy
Field(s) to sort results by in either ascending or descending order.
Supported fields include resourceId, resourceName, capacity, buildingId, and floorName.
If no order is specified, defaults to ascending.
Should be of the form "field [asc|desc], field [asc|desc], ...".
For example buildingId, capacity desc would return results sorted first by buildingId in ascending order then by capacity in descending order.


.PARAMETER Query
	String query used to filter results.
Should be of the form "field operator value" where field can be any of supported fields and operators can be any of supported operations.
Operators include '=' for exact match and ':' for prefix match or HAS match, depending on type of field.
For ':', when the field supports a scalar value, such as a String, and the value is followed by an asterisk (*), the query is considered a prefix match.
In a prefix match, the value must be at the start of a string to be a match.
For example, resourceName:Conference* returns all strings whose resourceName starts with "Conference," such as "Conference-Room-1."
For ':', when the field supports repeated values, such as featureInstances[].features, use a colon (:) without an asterisk (*) to indicate a HAS match.
For example, featureInstances.feature.name:Phone would return any calendar resource that has a feature instance whose name is "Phone" (all rooms with phones).
An asterisk (*) is only valid at end of value, it cannot be used at start or middle of value. For example, resourceName:*Room* doesn't work.
Query strings are case sensitive.
Supported fields include generatedResourceName, resourceName, name, buildingId, featureInstances.feature.name.



#>
}


Function Patch-ResourcesCalendars {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$BuildingId,
        [Parameter()]
        [string]$CalendarResourceId,
        [Parameter()]
        [string]$Capacity,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$FeatureInstances,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FloorName,
        [Parameter()]
        [string]$FloorSection,
        [Parameter()]
        [string]$ResourceCategory,
        [Parameter()]
        [string]$ResourceDescription,
        [Parameter()]
        [string]$ResourceName,
        [Parameter()]
        [string]$ResourceType,
        [Parameter()]
        [string]$UserVisibleDescription
    )

    BEGIN {
        $__PARAMETERMAP = @{
            BuildingId             = @{ OriginalName = '--buildingId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            CalendarResourceId     = @{ OriginalName = '--calendarResourceId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Capacity               = @{ OriginalName = '--capacity'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer               = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FeatureInstances       = @{ OriginalName = '--featureInstances'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                 = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorName              = @{ OriginalName = '--floorName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FloorSection           = @{ OriginalName = '--floorSection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceCategory       = @{ OriginalName = '--resourceCategory'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceDescription    = @{ OriginalName = '--resourceDescription'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceName           = @{ OriginalName = '--resourceName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ResourceType           = @{ OriginalName = '--resourceType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserVisibleDescription = @{ OriginalName = '--userVisibleDescription'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesCalendars"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patches a calendar resource.

.PARAMETER BuildingId
Unique ID for the building a resource is located in.


.PARAMETER CalendarResourceId
The unique ID of the calendar resource


.PARAMETER Capacity
Capacity of a resource, number of seats in a room.


.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER FeatureInstances
Instances of features for the calendar resource.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FloorName
Name of the floor a resource is located on.


.PARAMETER FloorSection
Name of the section within a floor a resource is located in.


.PARAMETER ResourceCategory
The category of the calendar resource. Either CONFERENCE_ROOM or OTHER. Legacy data is set to CATEGORY_UNKNOWN.

Acceptable values are:
CATEGORY_UNKNOWN
CONFERENCE_ROOM
OTHER


.PARAMETER ResourceDescription
Description of the resource, visible only to admins.


.PARAMETER ResourceName
The name of the calendar resource. For example, "Training Room 1A".


.PARAMETER ResourceType
The type of the calendar resource, intended for non-room resources.


.PARAMETER UserVisibleDescription
Description of the resource, visible to users and admins.



#>
}


Function Delete-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$FeatureKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FeatureKey = @{ OriginalName = '--featureKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a feature resource.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER FeatureKey
The unique ID of the feature.



#>
}


Function Get-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$FeatureKey,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FeatureKey = @{ OriginalName = '--featureKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a feature resource.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER FeatureKey
The unique ID of the feature.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Insert-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Name
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Name     = @{ OriginalName = '--name'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Inserts a feature resource.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Name
The name of the feature.



#>
}


Function List-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a list of feature resources for an account.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$FeatureKey,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FeatureKey = @{ OriginalName = '--featureKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patches a feature resource.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER FeatureKey
The unique ID of the feature.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Rename-ResourcesFeatures {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$NewName,
        [Parameter()]
        [string]$OldName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NewName  = @{ OriginalName = '--newName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OldName  = @{ OriginalName = '--oldName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "resourcesFeatures"
            "rename"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Renames a feature resource.

.PARAMETER Customer
The unique ID for the customer's Workspace account.
As an account administrator, you can also use the my_customer alias to represent your account's customer ID.


.PARAMETER NewName
New name of the feature.


.PARAMETER OldName
The unique ID of the feature to rename.



#>
}


Function Delete-Revisions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AcknowledgeAbuse,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$RevisionId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AcknowledgeAbuse = @{ OriginalName = '--acknowledgeAbuse'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            FileId           = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RevisionId       = @{ OriginalName = '--revisionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "revisions"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Permanently deletes a file version.

.PARAMETER AcknowledgeAbuse
Whether the user is acknowledging the risk of downloading known malware or other abusive files.
This is only applicable when alt=media.


.PARAMETER FileId
The ID of the file.


.PARAMETER RevisionId
The ID of the revision.



#>
}


Function Get-Revisions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AcknowledgeAbuse,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [string]$RevisionId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AcknowledgeAbuse = @{ OriginalName = '--acknowledgeAbuse'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId           = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RevisionId       = @{ OriginalName = '--revisionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "revisions"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a revision's metadata or content by ID.

.PARAMETER AcknowledgeAbuse
Whether the user is acknowledging the risk of downloading known malware or other abusive files.
This is only applicable when alt=media.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER RevisionId
The ID of the revision.



#>
}


Function List-Revisions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "revisions"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists a file's revisions.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.



#>
}


Function Update-Revisions {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$AcknowledgeAbuse,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$FileId,
        [Parameter()]
        [switch]$KeepForever,
        [Parameter()]
        [switch]$PublishAuto,
        [Parameter()]
        [switch]$Published,
        [Parameter()]
        [switch]$PublishedOutsideDomain	,
        [Parameter()]
        [string]$RevisionId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AcknowledgeAbuse       = @{ OriginalName = '--acknowledgeAbuse'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields                 = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FileId                 = @{ OriginalName = '--fileId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            KeepForever            = @{ OriginalName = '--keepForever'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            PublishAuto            = @{ OriginalName = '--publishAuto'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Published              = @{ OriginalName = '--published'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            PublishedOutsideDomain = @{ OriginalName = '--publishedOutsideDomain	'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            RevisionId             = @{ OriginalName = '--revisionId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "revisions"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a revision with patch semantics.

.PARAMETER AcknowledgeAbuse
Whether the user is acknowledging the risk of downloading known malware or other abusive files.
This is only applicable when alt=media.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER FileId
The ID of the file.


.PARAMETER KeepForever
Whether to keep this revision forever, even if it is no longer the head revision.
If not set, the revision will be automatically purged 30 days after newer content is uploaded.
This can be set on a maximum of 200 revisions for a file.
This field is only applicable to files with binary content in Drive.


.PARAMETER PublishAuto
Whether subsequent revisions will be automatically republished.
This is only applicable to Google Docs.


.PARAMETER Published
Whether this revision is published.
This is only applicable to Google Docs.


.PARAMETER PublishedOutsideDomain	
Whether this revision is published outside the domain.
This is only applicable to Google Docs.


.PARAMETER RevisionId
The ID of the revision.



#>
}


Function Delete-RoleAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$RoleAssignmentId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer         = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleAssignmentId = @{ OriginalName = '--roleAssignmentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roleAssignments"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a role assignment.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER RoleAssignmentId
Immutable ID of the role assignment.



#>
}


Function Get-RoleAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RoleAssignmentId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer         = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleAssignmentId = @{ OriginalName = '--roleAssignmentId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roleAssignments"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieve a role assignment.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RoleAssignmentId
Immutable ID of the role assignment.



#>
}


Function Insert-RoleAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AssignedTo,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrgUnitId,
        [Parameter()]
        [string]$RoleId,
        [Parameter()]
        [string]$ScopeType
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AssignedTo = @{ OriginalName = '--assignedTo'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer   = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitId  = @{ OriginalName = '--orgUnitId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleId     = @{ OriginalName = '--roleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ScopeType  = @{ OriginalName = '--scopeType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roleAssignments"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a role assignment.

.PARAMETER AssignedTo
The unique ID of the user this role is assigned to.


.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrgUnitId
If the role is restricted to an organization unit, this contains the ID for the organization unit the exercise of this role is restricted to.


.PARAMETER RoleId
The ID of the role that is assigned.


.PARAMETER ScopeType
The scope in which this role is assigned.
Acceptable values are:
CUSTOMER
ORG_UNIT



#>
}


Function List-RoleAssignments {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RoleId,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleId   = @{ OriginalName = '--roleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey  = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roleAssignments"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of all roleAssignments.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RoleId
The ID of the role that is assigned.


.PARAMETER UserKey
The user's primary email address, alias email address, or unique user ID.
If included in the request, returns role assignments only for this user.



#>
}


Function Delete-Roles {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$RoleId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleId   = @{ OriginalName = '--roleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roles"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a role.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER RoleId
Immutable ID of the role.



#>
}


Function Get-Roles {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RoleId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleId   = @{ OriginalName = '--roleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roles"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a role.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RoleId
Immutable ID of the role.



#>
}


Function Insert-Roles {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RoleName,
        [Parameter()]
        [string]$RolePrivileges
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer       = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleName       = @{ OriginalName = '--roleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RolePrivileges = @{ OriginalName = '--rolePrivileges'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roles"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a role.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RoleName
Name of the role.


.PARAMETER RolePrivileges
The set of privileges that are granted to this role.



#>
}


Function List-Roles {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roles"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of all the roles in a domain.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-Roles {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$RoleId,
        [Parameter()]
        [string]$RoleName,
        [Parameter()]
        [string]$RolePrivileges
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Customer       = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleId         = @{ OriginalName = '--roleId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RoleName       = @{ OriginalName = '--roleName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RolePrivileges = @{ OriginalName = '--rolePrivileges'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "roles"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a role. This method supports patch semantics.

.PARAMETER Customer
Immutable ID of the Workspace account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER RoleId
Immutable ID of the role.


.PARAMETER RoleName
Name of the role.


.PARAMETER RolePrivileges
The set of privileges that are granted to this role.



#>
}


Function Delete-Schemas {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$SchemaKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaKey  = @{ OriginalName = '--schemaKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "schemas"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a custom schema.

.PARAMETER CustomerId
Immutable ID of the G Suite account.


.PARAMETER SchemaKey
Name or immutable ID of the schema.



#>
}


Function Get-Schemas {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SchemaKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaKey  = @{ OriginalName = '--schemaKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "schemas"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieve a custom schema.

.PARAMETER CustomerId
Immutable ID of the G Suite account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SchemaKey
Name or immutable ID of the schema.



#>
}


Function Insert-Schemas {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DisplayName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SchemaFields,
        [Parameter()]
        [string]$SchemaName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId   = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DisplayName  = @{ OriginalName = '--displayName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaFields = @{ OriginalName = '--schemaFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaName   = @{ OriginalName = '--schemaName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "schemas"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Create a custom schema.

.PARAMETER CustomerId
Immutable ID of the G Suite account.


.PARAMETER DisplayName
Display name for the schema.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SchemaFields
The fields that should be present in this schema.
Can be used multiple times in the form of: "--schemaFields "fieldName=<Some Name>;fieldType=<Type>;multValued=[true|false]...
The following properties are available:
fieldName       - The name of the field.
fieldType       - The type of the field.
				  Possible values are:
                    - STRING  - "Text"
                    - DATE    - "Date
                    - INT64   - "Whole Number"
                    - BOOL    - "Yes or no"
                    - DOUBLE  - "Decimal Number"
                    - PHONE   - "Phone"
                    - EMAIL   - "Email"
multiValued     - A boolean specifying whether this is a multi-valued field or not. Default: false.
indexed         - Boolean specifying whether the field is indexed or not. Default: true.
displayName     - Display Name of the field.
readAccessType  - Specifies who can view values of this field. See Retrieve users as a non-administrator for more information.
				  Note: It may take up to 24 hours for changes to this field to be reflected.
minValue        - Minimum value of this field.
				  This is meant to be indicative rather than enforced.
				  Values outside this range will still be indexed, but search may not be as performant.
maxValue        - Maximum value of this field.
				  This is meant to be indicative rather than enforced.
				  Values outside this range will still be indexed, but search may not be as performant.


.PARAMETER SchemaName
The schema's name.



#>
}


Function List-Schemas {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$Fields
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "schemas"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List custom schemas

.PARAMETER CustomerId
Immutable ID of the G Suite account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.



#>
}


Function Patch-Schemas {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomerId,
        [Parameter()]
        [string]$DisplayName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SchemaFields,
        [Parameter()]
        [string]$SchemaKey,
        [Parameter()]
        [string]$SchemaName
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomerId   = @{ OriginalName = '--customerId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            DisplayName  = @{ OriginalName = '--displayName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields       = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaFields = @{ OriginalName = '--schemaFields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaKey    = @{ OriginalName = '--schemaKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SchemaName   = @{ OriginalName = '--schemaName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "schemas"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patches a custom schema

.PARAMETER CustomerId
Immutable ID of the G Suite account.


.PARAMETER DisplayName
Display name for the schema.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SchemaFields
The fields that should be present in this schema.
Can be used multiple times in the form of: "--schemaFields "fieldName=<Some Name>;fieldType=<Type>;multValued=[true|false]...
The following properties are available:
fieldName       - The name of the field.
fieldType       - The type of the field.
				  Possible values are:
                    - STRING  - "Text"
                    - DATE    - "Date
                    - INT64   - "Whole Number"
                    - BOOL    - "Yes or no"
                    - DOUBLE  - "Decimal Number"
                    - PHONE   - "Phone"
                    - EMAIL   - "Email"
multiValued     - A boolean specifying whether this is a multi-valued field or not. Default: false.
indexed         - Boolean specifying whether the field is indexed or not. Default: true.
displayName     - Display Name of the field.
readAccessType  - Specifies who can view values of this field. See Retrieve users as a non-administrator for more information.
				  Note: It may take up to 24 hours for changes to this field to be reflected.
minValue        - Minimum value of this field.
				  This is meant to be indicative rather than enforced.
				  Values outside this range will still be indexed, but search may not be as performant.
maxValue        - Maximum value of this field.
				  This is meant to be indicative rather than enforced.
				  Values outside this range will still be indexed, but search may not be as performant.


.PARAMETER SchemaKey
Name or immutable ID of the schema.


.PARAMETER SchemaName
The schema's name.



#>
}


Function Create-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DisplayName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Host_,
        [Parameter()]
        [switch]$IsDefault,
        [Parameter()]
        [string]$Password,
        [Parameter()]
        [string]$Port,
        [Parameter()]
        [string]$ReplyToAddress,
        [Parameter()]
        [string]$SecurityMode,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$Signature,
        [Parameter()]
        [switch]$TreatAsAlias,
        [Parameter()]
        [string]$UserId,
        [Parameter()]
        [string]$Username
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DisplayName    = @{ OriginalName = '--displayName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Host           = @{ OriginalName = '--host'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IsDefault      = @{ OriginalName = '--isDefault'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Password       = @{ OriginalName = '--password'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Port           = @{ OriginalName = '--port'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyToAddress = @{ OriginalName = '--replyToAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SecurityMode   = @{ OriginalName = '--securityMode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail    = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Signature      = @{ OriginalName = '--signature'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TreatAsAlias   = @{ OriginalName = '--treatAsAlias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Username       = @{ OriginalName = '--username'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a custom "from" send-as alias

.PARAMETER DisplayName
A name that appears in the "From:" header for mail sent using this alias.
For custom "from" addresses, when this is empty, Gmail will populate the "From:" header with the name that is used for the primary address associated with the account.
If the admin has disabled the ability for users to update their name format, requests to update this field for the primary login will silently fail.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Host
The hostname of the SMTP service. Required for SMTP.


.PARAMETER IsDefault
Whether this address is selected as the default "From:" address in situations such as composing a new message or sending a vacation auto-reply.
Every Gmail account has exactly one default send-as address, so the only legal value that clients may write to this field is true.
Changing this from false to true for an address will result in this field becoming false for the other previous default address.


.PARAMETER Password
The password that will be used for authentication with the SMTP service.


.PARAMETER Port
The port of the SMTP service. Required for SMTP.


.PARAMETER ReplyToAddress
An optional email address that is included in a "Reply-To:" header for mail sent using this alias.
If this is empty, Gmail will not generate a "Reply-To:" header.


.PARAMETER SecurityMode
The protocol that will be used to secure communication with the SMTP service. Required for SMTP.
[NONE|SSL|STARTTLS]
NONE      - Communication with the remote SMTP service is unsecured. Requires port 25.
SSL       - Communication with the remote SMTP service is secured using SSL.
STARTTLS  - Communication with the remote SMTP service is secured using STARTTLS.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER Signature
An optional HTML signature that is included in messages composed with this alias in the Gmail web UI.


.PARAMETER TreatAsAlias
Whether Gmail should treat this address as an alias for the user's primary email address.
This setting only applies to custom "from" aliases. See https://support.google.com/a/answer/1710338


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.


.PARAMETER Username
The username that will be used for authentication with the SMTP service.



#>
}


Function Delete-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes the specified send-as alias. Revokes any verification that may have been required for using it.

.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Get-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified send-as alias.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function List-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the send-as aliases for the specified account.
The result includes the primary send-as address associated with the account as well as any custom "from" aliases.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Patch-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$DisplayName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Host_,
        [Parameter()]
        [switch]$IsDefault,
        [Parameter()]
        [string]$Password,
        [Parameter()]
        [string]$Port,
        [Parameter()]
        [string]$ReplyToAddress,
        [Parameter()]
        [string]$SecurityMode,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$Signature,
        [Parameter()]
        [switch]$TreatAsAlias,
        [Parameter()]
        [string]$UserId,
        [Parameter()]
        [string]$Username
    )

    BEGIN {
        $__PARAMETERMAP = @{
            DisplayName    = @{ OriginalName = '--displayName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Host           = @{ OriginalName = '--host'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IsDefault      = @{ OriginalName = '--isDefault'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Password       = @{ OriginalName = '--password'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Port           = @{ OriginalName = '--port'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ReplyToAddress = @{ OriginalName = '--replyToAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SecurityMode   = @{ OriginalName = '--securityMode'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail    = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Signature      = @{ OriginalName = '--signature'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            TreatAsAlias   = @{ OriginalName = '--treatAsAlias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Username       = @{ OriginalName = '--username'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Patch the specified send-as alias.

.PARAMETER DisplayName
A name that appears in the "From:" header for mail sent using this alias.
For custom "from" addresses, when this is empty, Gmail will populate the "From:" header with the name that is used for the primary address associated with the account.
If the admin has disabled the ability for users to update their name format, requests to update this field for the primary login will silently fail.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Host
The hostname of the SMTP service. Required for SMTP.


.PARAMETER IsDefault
Whether this address is selected as the default "From:" address in situations such as composing a new message or sending a vacation auto-reply.
Every Gmail account has exactly one default send-as address, so the only legal value that clients may write to this field is true.
Changing this from false to true for an address will result in this field becoming false for the other previous default address.


.PARAMETER Password
The password that will be used for authentication with the SMTP service.


.PARAMETER Port
The port of the SMTP service. Required for SMTP.


.PARAMETER ReplyToAddress
An optional email address that is included in a "Reply-To:" header for mail sent using this alias.
If this is empty, Gmail will not generate a "Reply-To:" header.


.PARAMETER SecurityMode
The protocol that will be used to secure communication with the SMTP service. Required for SMTP.
[NONE|SSL|STARTTLS]
NONE      - Communication with the remote SMTP service is unsecured. Requires port 25.
SSL       - Communication with the remote SMTP service is secured using SSL.
STARTTLS  - Communication with the remote SMTP service is secured using STARTTLS.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER Signature
An optional HTML signature that is included in messages composed with this alias in the Gmail web UI.


.PARAMETER TreatAsAlias
Whether Gmail should treat this address as an alias for the user's primary email address.
This setting only applies to custom "from" aliases. See https://support.google.com/a/answer/1710338


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.


.PARAMETER Username
The username that will be used for authentication with the SMTP service.



#>
}


Function Verify-SendAs {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sendAs"
            "verify"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Sends a verification email to the specified send-as alias address. The verification status must be pending.

.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Create-SharedContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AdditionalName,
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$ExtendedProperty,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$FullName,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$Im,
        [Parameter()]
        [switch]$Json,
        [Parameter()]
        [string]$NamePrefix,
        [Parameter()]
        [string]$NameSuffix,
        [Parameter()]
        [string]$Organization,
        [Parameter()]
        [string]$PhoneNumber,
        [Parameter()]
        [string]$StructuredPostalAddress
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AdditionalName          = @{ OriginalName = '--additionalName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Domain                  = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Email                   = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExtendedProperty        = @{ OriginalName = '--extendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName              = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FullName                = @{ OriginalName = '--fullName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName               = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Im                      = @{ OriginalName = '--im'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Json                    = @{ OriginalName = '--json'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            NamePrefix              = @{ OriginalName = '--namePrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NameSuffix              = @{ OriginalName = '--nameSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organization            = @{ OriginalName = '--organization'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneNumber             = @{ OriginalName = '--phoneNumber'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StructuredPostalAddress = @{ OriginalName = '--structuredPostalAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sharedContacts"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Create a Domain Shared Contact

.PARAMETER AdditionalName
Additional name of the person, eg. middle name.


.PARAMETER Domain
DNS domain the contact should be created in


.PARAMETER Email
Email.
Must be in the form of "address=user@domain.com;displayName=Some Name;primary=[true|false];label=[Work|Home]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER ExtendedProperty
Extended Properties
Must be in the form of "name=Some Name;Value=Some Value;Realm=Some Realm"


.PARAMETER FamilyName
Person's family name.


.PARAMETER FullName
Unstructured representation of the name.


.PARAMETER GivenName
Person's given name.


.PARAMETER Im
IM addresses.
Must be in the form of "protocol=http://schemas.google.com/g/2005#GOOGLE_TALK;address=some@address.com;primary=[true|false]label=[Work|Home|Mobile]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER Json
Output as JSON"


.PARAMETER NamePrefix
Honorific prefix, eg. 'Mr' or 'Mrs'.


.PARAMETER NameSuffix
Honorific suffix, eg. 'san' or 'III'.


.PARAMETER Organization
Organization of the contact.
Must be in the form of "orgName=Some Company;orgDepartment=Some Department;orgTitle=Some Title;orgJobDescription=Some Description;orgSymbol=Some Symbol"


.PARAMETER PhoneNumber
Phone number.
Must be in the form of "phoneNumber=+1 212 213181;primary=[true|false]label=[Work|Home|Mobile]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER StructuredPostalAddress
Structed Postal Address
Must be in the form of "mailClass=...;label=...;usage=...;primary=[true|false];agent=...;housename=...;street=...;pobox=...neighborhood=...;city=...;subregion=...;region=...;postcode=...;country=...;formattedAddress=..."



#>
}


Function Delete-SharedContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$Url
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Domain = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Url    = @{ OriginalName = '--url'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sharedContacts"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete a shared contact by referencing its id url

.PARAMETER Domain
DNS domain the contact should be created in


.PARAMETER Url
URL of the Shared Contact (Retrieve with "list" and look for "id").
MUST BE https://!



#>
}


Function Get-SharedContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [switch]$Json,
        [Parameter()]
        [string]$Url
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Domain = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Json   = @{ OriginalName = '--json'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Url    = @{ OriginalName = '--url'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sharedContacts"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a Domain Shared Contact via its URL / ID

.PARAMETER Domain
DNS domain the contact should be created in


.PARAMETER Json
Output as JSON"


.PARAMETER Url
URL of the Shared Contact (Retrieve with "list" and look for "id").
MUST BE https://!



#>
}


Function List-SharedContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [switch]$Json
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Domain = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Json   = @{ OriginalName = '--json'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sharedContacts"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
List all shared contacts in your domain

.PARAMETER Domain
DNS domain the contact should be created in


.PARAMETER Json
Output as JSON"



#>
}


Function Update-SharedContacts {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AdditionalName,
        [Parameter()]
        [string]$Email,
        [Parameter()]
        [string]$ExtendedProperty,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$FullName,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$Im,
        [Parameter()]
        [switch]$Json,
        [Parameter()]
        [string]$NamePrefix,
        [Parameter()]
        [string]$NameSuffix,
        [Parameter()]
        [string]$Organization,
        [Parameter()]
        [string]$PhoneNumber,
        [Parameter()]
        [string]$StructuredPostalAddress,
        [Parameter()]
        [string]$Url
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AdditionalName          = @{ OriginalName = '--additionalName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Email                   = @{ OriginalName = '--email'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExtendedProperty        = @{ OriginalName = '--extendedProperty'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName              = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FullName                = @{ OriginalName = '--fullName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName               = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Im                      = @{ OriginalName = '--im'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Json                    = @{ OriginalName = '--json'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            NamePrefix              = @{ OriginalName = '--namePrefix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NameSuffix              = @{ OriginalName = '--nameSuffix'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organization            = @{ OriginalName = '--organization'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PhoneNumber             = @{ OriginalName = '--phoneNumber'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            StructuredPostalAddress = @{ OriginalName = '--structuredPostalAddress'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Url                     = @{ OriginalName = '--url'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "sharedContacts"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Update a shared contact

.PARAMETER AdditionalName
Additional name of the person, eg. middle name.


.PARAMETER Email
Email.
Must be in the form of "address=user@domain.com;displayName=Some Name;primary=[true|false];label=[Work|Home]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER ExtendedProperty
Extended Properties
Must be in the form of "name=Some Name;Value=Some Value;Realm=Some Realm"


.PARAMETER FamilyName
Person's family name.


.PARAMETER FullName
Unstructured representation of the name.


.PARAMETER GivenName
Person's given name.


.PARAMETER Im
IM addresses.
Must be in the form of "protocol=http://schemas.google.com/g/2005#GOOGLE_TALK;address=some@address.com;primary=[true|false]label=[Work|Home|Mobile]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER Json
Output as JSON"


.PARAMETER NamePrefix
Honorific prefix, eg. 'Mr' or 'Mrs'.


.PARAMETER NameSuffix
Honorific suffix, eg. 'san' or 'III'.


.PARAMETER Organization
Organization of the contact.
Must be in the form of "orgName=Some Company;orgDepartment=Some Department;orgTitle=Some Title;orgJobDescription=Some Description;orgSymbol=Some Symbol"


.PARAMETER PhoneNumber
Phone number.
Must be in the form of "phoneNumber=+1 212 213181;primary=[true|false]label=[Work|Home|Mobile]".
Can be used multiple time (although "primary" may only be used once


.PARAMETER StructuredPostalAddress
Structed Postal Address
Must be in the form of "mailClass=...;label=...;usage=...;primary=[true|false];agent=...;housename=...;street=...;pobox=...neighborhood=...;city=...;subregion=...;region=...;postcode=...;country=...;formattedAddress=..."


.PARAMETER Url
URL of the Shared Contact (Retrieve with "list" and look for "id").
MUST BE https://!



#>
}


Function Delete-SmimeInfo {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id          = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "smimeInfo"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes the specified S/MIME config for the specified send-as alias.

.PARAMETER Id
The immutable ID for the SmimeInfo.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Get-SmimeInfo {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id          = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "smimeInfo"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified S/MIME config for the specified send-as alias.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
The immutable ID for the SmimeInfo.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Insert-SmimeInfo {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$EncryptedKeyPassword,
        [Parameter()]
        [switch]$Expiration,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IsDefault,
        [Parameter()]
        [string]$IssuerCn,
        [Parameter()]
        [switch]$Pem,
        [Parameter()]
        [switch]$Pkcs12,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            EncryptedKeyPassword = @{ OriginalName = '--encryptedKeyPassword'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Expiration           = @{ OriginalName = '--expiration'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Fields               = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IsDefault            = @{ OriginalName = '--isDefault'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IssuerCn             = @{ OriginalName = '--issuerCn'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Pem                  = @{ OriginalName = '--pem'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Pkcs12               = @{ OriginalName = '--pkcs12'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            SendAsEmail          = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId               = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "smimeInfo"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Insert (upload) the given S/MIME config for the specified send-as alias.
Note that pkcs12 format is required for the key.

.PARAMETER EncryptedKeyPassword
Encrypted key password, when key is encrypted.


.PARAMETER Expiration
When the certificate expires (in milliseconds since epoch).


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IsDefault
The S/MIME certificate issuer's common name.


.PARAMETER IssuerCn
The S/MIME certificate issuer's common name.


.PARAMETER Pem
PEM formatted X509 concatenated certificate string (standard base64 encoding).
Format used for returning key, which includes public key as well as certificate chain (not private key).


.PARAMETER Pkcs12
PKCS#12 format containing a single private/public key pair and certificate chain.
This format is only accepted from client for creating a new SmimeInfo and is never returned, because the private key is not intended to be exported.
PKCS#12 may be encrypted, in which case encryptedKeyPassword should be set appropriately.

A base64-encoded string.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function List-SmimeInfo {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields      = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "smimeInfo"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists S/MIME configs for the specified send-as alias.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function SetDefault-SmimeInfo {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$SendAsEmail,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id          = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SendAsEmail = @{ OriginalName = '--sendAsEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId      = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "smimeInfo"
            "setDefault"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Sets the default S/MIME config for the specified send-as alias.

.PARAMETER Id
The immutable ID for the SmimeInfo.


.PARAMETER SendAsEmail
The email address that appears in the "From:" header for mail sent using this alias.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function BatchUpdate-Spreadsheets {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CsvFileToUpload,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$SpreadsheetId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CsvFileToUpload = @{ OriginalName = '--csvFileToUpload'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SpreadsheetId   = @{ OriginalName = '--spreadsheetId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "spreadsheets"
            "batchUpdate"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Applies one or more updates to the spreadsheet.

.PARAMETER CsvFileToUpload
A list of CSV files that should be added to the spreadsheet as new sheets.
Can be used multiple times in the form of "--csvFileToUpload "title=Some Title;path=./path/to/file.csv""
Delimiter must be ","


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER SpreadsheetId
The ID of the spreadsheet



#>
}


Function Create-Spreadsheets {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CsvFileToUpload,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Title
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CsvFileToUpload = @{ OriginalName = '--csvFileToUpload'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Title           = @{ OriginalName = '--title'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "spreadsheets"
            "create"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a spreadsheet, returning the newly created spreadsheet.

.PARAMETER CsvFileToUpload
A list of CSV files that should be added to the spreadsheet as new sheets.
Can be used multiple times in the form of "--csvFileToUpload "title=Some Title;path=./path/to/file.csv""
Delimiter must be ","


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Title
The ID of the spreadsheet



#>
}


Function Get-Spreadsheets {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeGridData,
        [Parameter()]
        [string]$Ranges,
        [Parameter()]
        [string]$SpreadsheetId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeGridData = @{ OriginalName = '--includeGridData'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Ranges          = @{ OriginalName = '--ranges'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SpreadsheetId   = @{ OriginalName = '--spreadsheetId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "spreadsheets"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets a spreadsheet, returning the newly getd spreadsheet.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeGridData
True if grid data should be returned.
This parameter is ignored if a field mask was set in the request.


.PARAMETER Ranges
The ranges to retrieve from the spreadsheet.


.PARAMETER SpreadsheetId
The ID of the spreadsheet



#>
}


Function Delete-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Immediately and permanently deletes the specified thread.
This operation cannot be undone. Prefer threads trash instead.

.PARAMETER Id
ID of the Thread.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Get-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Format,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$MetadataHeaders,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Format          = @{ OriginalName = '--format'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id              = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            MetadataHeaders = @{ OriginalName = '--metadataHeaders'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId          = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Gets the specified thread.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Format
The format to return the message in.
[MINIMAL|FULL|RAW|METADATA]
MINIMAL   - Returns only email message ID and labels; does not return the email headers, body, or payload.
FULL      - Returns the full email message data with body content parsed in the payload field; the raw field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
RAW       - Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used. Format cannot be used when accessing the api using the gmail.metadata scope.
METADATA  - Returns only email message ID, labels, and email headers.


.PARAMETER Id
ID of the Thread.


.PARAMETER MetadataHeaders
When given and format is METADATA, only include headers specified.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function List-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [switch]$IncludeSpamTrash,
        [Parameter()]
        [string]$LabelIds,
        [Parameter()]
        [string]$Q,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields           = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeSpamTrash = @{ OriginalName = '--includeSpamTrash'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            LabelIds         = @{ OriginalName = '--labelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Q                = @{ OriginalName = '--q'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId           = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists the threads in the user's mailbox.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER IncludeSpamTrash
Include threads from SPAM and TRASH in the results.


.PARAMETER LabelIds
Only return threads with labels that match all of the specified label IDs.


.PARAMETER Q
Only return threads matching the specified query.
Supports the same query format as the Gmail search box.
For example, "from:someuser@example.com rfc822msgid:<somemsgid@example.com> is:unread".
Parameter cannot be used when accessing the api using the gmail.metadata scope.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Modify-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$AddLabelIds,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$RemoveLabelIds,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            AddLabelIds    = @{ OriginalName = '--addLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields         = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id             = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RemoveLabelIds = @{ OriginalName = '--removeLabelIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId         = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "modify"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Modifies the labels applied to the thread. This applies to all messages in the thread.

.PARAMETER AddLabelIds
A list of label IDs to add to threads.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
ID of the Thread.


.PARAMETER RemoveLabelIds
A list of label IDs to remove from threads.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Trash-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "trash"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Moves the specified thread to the trash.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
ID of the Thread.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Untrash-Threads {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Id,
        [Parameter()]
        [string]$UserId
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Id     = @{ OriginalName = '--id'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserId = @{ OriginalName = '--userId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "threads"
            "untrash"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes the specified thread from the trash.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Id
ID of the Thread.


.PARAMETER UserId
The user's email address. The special value me can be used to indicate the authenticated user.



#>
}


Function Delete-Tokens {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ClientId,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ClientId = @{ OriginalName = '--clientId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey  = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "tokens"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Delete all access tokens issued by a user for an application.

.PARAMETER ClientId
The Client ID of the application the token is issued to.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Get-Tokens {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$ClientId,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            ClientId = @{ OriginalName = '--clientId'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields   = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey  = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "tokens"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Get information about an access token issued by a user.

.PARAMETER ClientId
The Client ID of the application the token is issued to.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function List-Tokens {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "tokens"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the set of tokens specified user has issued to 3rd party applications.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function TurnOff-TwoStepVerification {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "twoStepVerification"
            "turnOff"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Turn off 2-Step Verification for user.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Delete-UserAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Alias,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Alias   = @{ OriginalName = '--alias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userAliases"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes an alias.

.PARAMETER Alias
The alias email address.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Insert-UserAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Alias,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Alias   = @{ OriginalName = '--alias'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userAliases"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds an alias.

.PARAMETER Alias
The alias email address.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function List-UserAliases {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userAliases"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Lists all aliases for a user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Delete-UserPhotos {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userPhotos"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Removes the user's photo.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Get-UserPhotos {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userPhotos"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves the user's photo.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Update-UserPhotos {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Photo,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Photo   = @{ OriginalName = '--photo'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "userPhotos"
            "update"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Adds a user or group to the specified group.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Photo
Path to the photo file.
Allowed formats are: jpeg, png, gif, bmp and tiff.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Delete-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "delete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Deletes a user.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Get-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomFieldMask,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$Projection,
        [Parameter()]
        [string]$UserKey,
        [Parameter()]
        [string]$ViewType
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomFieldMask = @{ OriginalName = '--customFieldMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection      = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey         = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ViewType        = @{ OriginalName = '--viewType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "get"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a user.

.PARAMETER CustomFieldMask
A comma-separated list of schema names.
All fields from these schemas are fetched. This should only be set when projection=custom


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER Projection
What subset of fields to fetch for this user.

Acceptable values are:
basic   - Do not include any custom fields for the user. (default)
custom  - Include custom fields from schemas requested in customFieldMask.
full    - Include all fields associated with this user.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.


.PARAMETER ViewType
Whether to fetch the administrator-only or domain-wide public view of the user.
For more information, see https://developers.google.com/admin-sdk/directory/v1/guides/manage-users#retrieve_users_non_admin.

Acceptable values are:
admin_view     - Results include both administrator-only and domain-public fields for the user. (default)
domain_public  - Results only include fields for the user that are publicly visible to other users in the domain.
                 Contact sharing must be enabled for the domain.



#>
}


Function Insert-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Addresses,
        [Parameter()]
        [switch]$Archived,
        [Parameter()]
        [switch]$ChangePasswordAtNextLogin,
        [Parameter()]
        [string]$CustomGender,
        [Parameter()]
        [string]$Emails,
        [Parameter()]
        [string]$ExternalIds,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GenderType,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$HashFunction,
        [Parameter()]
        [string]$Ims,
        [Parameter()]
        [switch]$IncludeInGlobalAddressList,
        [Parameter()]
        [switch]$IpWhitelisted,
        [Parameter()]
        [string]$Keywords,
        [Parameter()]
        [string]$Languages,
        [Parameter()]
        [string]$Locations,
        [Parameter()]
        [string]$NotesContentType,
        [Parameter()]
        [string]$NotesValue,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$Organizations,
        [Parameter()]
        [string]$Password,
        [Parameter()]
        [string]$Phones,
        [Parameter()]
        [string]$PosixAccounts,
        [Parameter()]
        [string]$PrimaryEmail,
        [Parameter()]
        [string]$RecoveryEmail,
        [Parameter()]
        [string]$RecoveryPhone,
        [Parameter()]
        [string]$Relations,
        [Parameter()]
        [string]$SshPublicKeys,
        [Parameter()]
        [switch]$Suspended,
        [Parameter()]
        [string]$Websites
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Addresses                  = @{ OriginalName = '--addresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Archived                   = @{ OriginalName = '--archived'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ChangePasswordAtNextLogin  = @{ OriginalName = '--changePasswordAtNextLogin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CustomGender               = @{ OriginalName = '--customGender'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Emails                     = @{ OriginalName = '--emails'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExternalIds                = @{ OriginalName = '--externalIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName                 = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GenderType                 = @{ OriginalName = '--genderType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName                  = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HashFunction               = @{ OriginalName = '--hashFunction'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Ims                        = @{ OriginalName = '--ims'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeInGlobalAddressList = @{ OriginalName = '--includeInGlobalAddressList'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IpWhitelisted              = @{ OriginalName = '--ipWhitelisted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Keywords                   = @{ OriginalName = '--keywords'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Languages                  = @{ OriginalName = '--languages'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locations                  = @{ OriginalName = '--locations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotesContentType           = @{ OriginalName = '--notesContentType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotesValue                 = @{ OriginalName = '--notesValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath                = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organizations              = @{ OriginalName = '--organizations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Password                   = @{ OriginalName = '--password'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Phones                     = @{ OriginalName = '--phones'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PosixAccounts              = @{ OriginalName = '--posixAccounts'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrimaryEmail               = @{ OriginalName = '--primaryEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RecoveryEmail              = @{ OriginalName = '--recoveryEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RecoveryPhone              = @{ OriginalName = '--recoveryPhone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Relations                  = @{ OriginalName = '--relations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SshPublicKeys              = @{ OriginalName = '--sshPublicKeys'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Suspended                  = @{ OriginalName = '--suspended'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Websites                   = @{ OriginalName = '--websites'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "insert"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Creates a user.

.PARAMETER Addresses
Specifies addresses for the user. May be used multiple times in the form of:
'--addresses "country=...;countryCode=..;customType=..."', etc.
You can use the following properties:
country             - Country.
countryCode         - The country code. Uses the ISO 3166-1 standard.
customType          - If the address type is custom, this property contains the custom value.
extendedAddress     - For extended addresses, such as an address that includes a sub-region.
formatted           - A full and unstructured postal address. This is not synced with the structured address fields.
locality            - The town or city of the address.
poBox               - The post office box, if present.
postalCode          - The ZIP or postal code, if applicable.
primary             - BOOL! If this is the user's primary address. The addresses list may contain only one primary address.
region              - The abbreviated province or state.
sourceIsStructured  - BOOL! Indicates if the user-supplied address was formatted. Formatted addresses are not currently supported.
streetAddress       - The street address, such as 1600 Amphitheatre Parkway. Whitespace within the string is ignored; however, newlines are significant.
type                - The address type.
                      Acceptable values are:
                        - "custom"
                        - "home"
                        - "other"
						- "work"


.PARAMETER Archived
Indicates if user is archived.


.PARAMETER ChangePasswordAtNextLogin
Indicates if the user is forced to change their password at next login.
This setting doesn't apply when the user signs in via a third-party identity provider.


.PARAMETER CustomGender
Custom gender.


.PARAMETER Emails
Specifies email addresses for the user. May be used multiple times in the form of:
'--emails "address=...;customType=..;primary=..."', etc.
You can use the following properties:
address     - Country.
customType  - The country code. Uses the ISO 3166-1 standard.
primary     - If the address type is custom, this property contains the custom value.
type        - The type of the email account.
              Acceptable values are:
                - "custom"
                - "home"
                - "other"
                - "work"


.PARAMETER ExternalIds
Specifies externalIds for the user. May be used multiple times in the form of:
'--externalIds "customType=...;type=..;value=..."'
You can use the following properties:
customType  - Country.
type        - The type of the ID.
              Acceptable values are:
                - "account"
                - "custom"
                - "customer"
				- "login_id"
				- "network"
				- "organization": IDs of this type map to employee ID in the Admin Console
value           - The value of the ID.


.PARAMETER FamilyName
The user's last name. Required when creating a user account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GenderType
Gender.
Acceptable values are:
female
male
other
unknown


.PARAMETER GivenName
The user's first name. Required when creating a user account.


.PARAMETER HashFunction
Stores the hash format of the password property.
We recommend sending the password property value as a base 16 bit hexadecimal-encoded hash value.
Set the hashFunction values as either the SHA-1, MD5, or crypt hash format.


.PARAMETER Ims
The user's Instant Messenger (IM) accounts.
A user account can have multiple ims properties.
But, only one of these ims properties can be the primary IM contact.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--ims "customProtocol=...;customType=..;im=..."', etc.
You can use the following properties:
customProtocol  - If the protocol value is custom_protocol, this property holds the custom protocol's string.
customType      - If the IM type is custom, this property holds the custom type string.
im              - The user's IM network ID.
primary         - BOOL! If this is the user's primary IM. Only one entry in the IM list can have a value of true.
protocol        - An IM protocol identifies the IM network. The value can be a custom network or the standard network.
                  Acceptable values are:
                    - "aim": AOL Instant Messenger protocol
                    - "custom_protocol": A custom IM network protocol
                    - "gtalk": Google Talk protocol
                    - "icq": ICQ protocol
                    - "jabber": Jabber protocol
                    - "msn": MSN Messenger protocol
                    - "net_meeting": Net Meeting protocol
                    - "qq": QQ protocol
                    - "skype": Skype protocol
                    - "yahoo": Yahoo Messenger protocol
type            - The type of the IM account.
                  Acceptable values are:
                   - "custom"
                   - "home"
                   - "other"
                   - "work"


.PARAMETER IncludeInGlobalAddressList
Indicates if the user's profile is visible in the Workspace global address list when the contact sharing feature is enabled for the domain.
For more information about excluding user profiles, see the administration help center.


.PARAMETER IpWhitelisted
If true, the user's IP address is white listed.


.PARAMETER Keywords
The user's keywords. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--keywords "customType=...;type=..;value=..."'
You can use the following properties:
customType  - Custom Type.
type        - Each entry can have a type which indicates standard type of that entry.
              For example, keyword could be of type occupation or outlook.
              In addition to the standard type, an entry can have a custom type and can give it any name.
              Such types should have the CUSTOM value as type and also have a customType value.
              Acceptable values are:
                - "custom"
                - "mission"
                - "occupation"
				- "outlook"
value  -      Keyword.


.PARAMETER Languages
The user's languages. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--languages "customLanguage=..."'
'--languages "languageCode=..."'
You can use the following properties:
customLanguage  - Other language.
				  A user can provide their own language name if there is no corresponding Google III language code.
			      If this is set, LanguageCode can't be set
languageCode    - Language Code.
                  Should be used for storing Google III LanguageCode string representation for language.
				  Illegal values cause SchemaException.


.PARAMETER Locations
The user's locations. The maximum allowed data size for this field is 10Kb.
May be used multiple times in the form of:
'--locations "area=...;buildingId=...;customType=..."', etc.
You can use the following properties:
area          - Textual location.
		        This is most useful for display purposes to concisely describe the location.
		        For example, "Mountain View, CA", "Near Seattle".
buildingId    - Building identifier.
customType    - If the location type is custom, this property contains the custom value.
deskCode      - Most specific textual code of individual desk location.
floorName     - Floor name/number.
floorSection  - Floor section. More specific location within the floor.
                  For example, if a floor is divided into sections "A", "B", and "C", this field would identify one of those values.
type          - The location type.
                Acceptable values are:
                  - "custom"
                  - "default"
				  - "desk"


.PARAMETER NotesContentType
Content type of note, either plain text or HTML.
Default is plain text. Possible values are:
text_plain
text_html


.PARAMETER NotesValue
Contents of notes.


.PARAMETER OrgUnitPath
The full path of the parent organization associated with the user.
If the parent organization is the top-level, it is represented as a forward slash (/).


.PARAMETER Organizations
A list of organizations the user belongs to. The maximum allowed data size for this field is 10Kb.
May be used multiple times in the form of:
'--organizations "costCenter=...;customType=...;department=..."', etc.
You can use the following properties:
costCenter          - The cost center of the user's organization.
customType          - If the value of type is custom, this property contains the custom type.
department          - Specifies the department within the organization, such as 'sales' or 'engineering'.
description         - The description of the organization.
domain              - The domain the organization belongs to.
fullTimeEquivalent  - INT! The full-time equivalent millipercent within the organization (100000 = 100%).	
location            - The physical location of the organization.
			          This does not need to be a fully qualified address.
name                - The name of the organization.
primary             - BOOL! Indicates if this is the user's primary organization.
                      A user may only have one primary organization.
symbol              - Text string symbol of the organization.
                      For example, the text symbol for Google is GOOG.
title               - The user's title within the organization, for example 'member' or 'engineer'.
type                - The type of organization.
                      Acceptable values are:
                        - "domain_only"
                        - "school"
                        - "unknown"
						- "work"


.PARAMETER Password
Stores the password for the user account.
The user's password value is required when creating a user account.
It is optional when updating a user and should only be provided if the user is updating their account password.
A password can contain any combination of ASCII characters.
A minimum of 8 characters is required. The maximum length is 100 characters.
We recommend sending the password property value as a base 16 bit, hexadecimal-encoded hash value.
If a hashFunction is specified, the password must be a valid hash key.
The password value is never returned in the API's response body.


.PARAMETER Phones
A list of the user's phone numbers. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--phones "customType=...;primary=...;type=..."', etc.
You can use the following properties:
customType  - If the value of type is custom, this property contains the custom type.
primary     - BOOL! Indicates if this is the user's primary phone number.
              A user may only have one primary phone number.
type        - The type of phone number.
              Acceptable values are:
                - "assistant"
                - "callback"
                - "car"
                - "company_main"
                - "custom"
                - "grand_central"
                - "home"
                - "home_fax"
                - "isdn"
                - "main"
                - "mobile"
                - "other"
                - "other_fax"
                - "pager"
                - "radio"
                - "telex"
                - "tty_tdd"
                - "work"
                - "work_fax"
                - "work_mobile"
		        - "work_pager"
value       - A human-readable phone number.
			  It may be in any telephone number format.


.PARAMETER PosixAccounts
A list of POSIX account information for the user.
May be used multiple times in the form of:
'--posixAccounts "accountId=...;gecos=...;gid=..."', etc.
You can use the following properties:
accountId            - A POSIX account field identifier.
gecos                - The GECOS (user information) for this account.
gid                  - The default group ID.
homeDirectory        - The path to the home directory for this account.
operatingSystemType  - The operating system type for this account.
                       Acceptable values are:
                         - "linux"
                         - "unspecified"
                         - "windows"
primary              - BOOL! If this is user's primary account within the SystemId.
shell                - The path to the login shell for this account.
systemId             - System identifier for which account Username or Uid apply to.
uid                  - The POSIX compliant user ID.
username             - The username of the account.


.PARAMETER PrimaryEmail
The user's primary email address.
This property is required in a request to create a user account.
The primaryEmail must be unique and cannot be an alias of another user.


.PARAMETER RecoveryEmail
Recovery email of the user.


.PARAMETER RecoveryPhone
Recovery phone of the user.
The phone number must be in the E.164 format, starting with the plus sign (+).
Example: +16506661212.


.PARAMETER Relations
A list of the user's relationships to other users.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--relations "customType=...;type=...;value=..."'
You can use the following properties:
customType  - If the value of type is custom, this property contains the custom type.
type        - The type of relation.
              Acceptable values are:
              - "admin_assistant"
              - "assistant"
              - "brother"
              - "child"
              - "custom"
              - "domestic_partner"
              - "dotted_line_manager"
              - "exec_assistant"
              - "father"
              - "friend"
              - "manager"
              - "mother"
              - "parent"
              - "partner"
              - "referred_by"
              - "relative"
              - "sister"
			  - "spouse"
value       - The name of the person the user is related to.


.PARAMETER SshPublicKeys
A list of SSH public keys.
May be used multiple times in the form of:
'--sshPublicKeys "expirationTimeUsec=...;key=..."'
You can use the following properties:
expirationTimeUsec  - An expiration time in microseconds since epoch.
key                 - An SSH public key.


.PARAMETER Suspended
Indicates if user is suspended.


.PARAMETER Websites
The user's websites.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--websites "customType=...;primary=...;type=..."', etc.
You can use the following properties:
customType  - The custom type. Only used if the type is custom.
primary     - BOOL! If this is user's primary website or not.
type        - The type or purpose of the website.
			  For example, a website could be labeled as home or blog.
			  Alternatively, an entry can have a custom type.
			  Custom types must have a customType value.
			  Acceptable values are:
			    - "app_install_page"
			    - "blog"
			    - "custom"
			    - "ftp"
			    - "home"
			    - "home_page"
			    - "other"
			    - "profile"
			    - "reservations"
			    - "resume"
			    - "work"
value       - The URL of the website.



#>
}


Function List-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$CustomFieldMask,
        [Parameter()]
        [string]$Customer,
        [Parameter()]
        [string]$Domain,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$OrderBy,
        [Parameter()]
        [string]$Projection,
        [Parameter()]
        [string]$Query,
        [Parameter()]
        [switch]$ShowDeleted,
        [Parameter()]
        [string]$SortOrder,
        [Parameter()]
        [string]$ViewType
    )

    BEGIN {
        $__PARAMETERMAP = @{
            CustomFieldMask = @{ OriginalName = '--customFieldMask'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Customer        = @{ OriginalName = '--customer'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Domain          = @{ OriginalName = '--domain'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields          = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrderBy         = @{ OriginalName = '--orderBy'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Projection      = @{ OriginalName = '--projection'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Query           = @{ OriginalName = '--query'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ShowDeleted     = @{ OriginalName = '--showDeleted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            SortOrder       = @{ OriginalName = '--sortOrder'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ViewType        = @{ OriginalName = '--viewType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Retrieves a paginated list of either deleted users or all users in a domain.

.PARAMETER CustomFieldMask
A comma-separated list of schema names.
All fields from these schemas are fetched. This should only be set when projection=custom


.PARAMETER Customer
The unique ID for the customer's Workspace account.
In case of a multi-domain account, to fetch all groups for a customer, fill this field instead of domain.
You can also use the my_customer alias to represent your account's customerId.
The customerId is also returned as part of the Users resource.
Either the customer or the domain parameter must be provided.


.PARAMETER Domain
The domain name.
Use this field to get fields from only one domain.
To return all domains for a customer account, use the customer query parameter instead.
Either the customer or the domain parameter must be provided.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER OrderBy
Property to use for sorting results.
Acceptable values are:
email       - Primary email of the user.
familyName  - User's family name.
givenName   - User's given name.


.PARAMETER Projection
What subset of fields to fetch for this user.

Acceptable values are:
basic   - Do not include any custom fields for the user. (default)
custom  - Include custom fields from schemas requested in customFieldMask.
full    - Include all fields associated with this user.


.PARAMETER Query
Query string for searching user fields.
For more information on constructing user queries, see https://developers.google.com/admin-sdk/directory/v1/guides/search-users


.PARAMETER ShowDeleted
If set to true, retrieves the list of deleted users.


.PARAMETER SortOrder
Whether to return results in ascending or descending order.
Acceptable values are:
ASCENDING   - Ascending order.
DESCENDING  - Descending order.


.PARAMETER ViewType
Whether to fetch the administrator-only or domain-wide public view of the user.
For more information, see https://developers.google.com/admin-sdk/directory/v1/guides/manage-users#retrieve_users_non_admin.

Acceptable values are:
admin_view     - Results include both administrator-only and domain-public fields for the user. (default)
domain_public  - Results only include fields for the user that are publicly visible to other users in the domain.
                 Contact sharing must be enabled for the domain.



#>
}


Function MakeAdmin-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [switch]$Unmake,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Unmake  = @{ OriginalName = '--unmake'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "makeAdmin"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
(un)Makes a user a super administrator.

.PARAMETER Unmake
Use to remove admin access.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Patch-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Addresses,
        [Parameter()]
        [switch]$Archived,
        [Parameter()]
        [switch]$ChangePasswordAtNextLogin,
        [Parameter()]
        [string]$CustomGender,
        [Parameter()]
        [string]$Emails,
        [Parameter()]
        [string]$ExternalIds,
        [Parameter()]
        [string]$FamilyName,
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$GenderType,
        [Parameter()]
        [string]$GivenName,
        [Parameter()]
        [string]$HashFunction,
        [Parameter()]
        [string]$Ims,
        [Parameter()]
        [switch]$IncludeInGlobalAddressList,
        [Parameter()]
        [switch]$IpWhitelisted,
        [Parameter()]
        [string]$Keywords,
        [Parameter()]
        [string]$Languages,
        [Parameter()]
        [string]$Locations,
        [Parameter()]
        [string]$NotesContentType,
        [Parameter()]
        [string]$NotesValue,
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$Organizations,
        [Parameter()]
        [string]$Password,
        [Parameter()]
        [string]$Phones,
        [Parameter()]
        [string]$PosixAccounts,
        [Parameter()]
        [string]$PrimaryEmail,
        [Parameter()]
        [string]$RecoveryEmail,
        [Parameter()]
        [string]$RecoveryPhone,
        [Parameter()]
        [string]$Relations,
        [Parameter()]
        [string]$SshPublicKeys,
        [Parameter()]
        [switch]$Suspended,
        [Parameter()]
        [string]$UserKey,
        [Parameter()]
        [string]$Websites
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Addresses                  = @{ OriginalName = '--addresses'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Archived                   = @{ OriginalName = '--archived'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            ChangePasswordAtNextLogin  = @{ OriginalName = '--changePasswordAtNextLogin'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            CustomGender               = @{ OriginalName = '--customGender'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Emails                     = @{ OriginalName = '--emails'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            ExternalIds                = @{ OriginalName = '--externalIds'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            FamilyName                 = @{ OriginalName = '--familyName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Fields                     = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GenderType                 = @{ OriginalName = '--genderType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            GivenName                  = @{ OriginalName = '--givenName'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            HashFunction               = @{ OriginalName = '--hashFunction'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Ims                        = @{ OriginalName = '--ims'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            IncludeInGlobalAddressList = @{ OriginalName = '--includeInGlobalAddressList'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            IpWhitelisted              = @{ OriginalName = '--ipWhitelisted'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            Keywords                   = @{ OriginalName = '--keywords'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Languages                  = @{ OriginalName = '--languages'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Locations                  = @{ OriginalName = '--locations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotesContentType           = @{ OriginalName = '--notesContentType'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            NotesValue                 = @{ OriginalName = '--notesValue'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            OrgUnitPath                = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Organizations              = @{ OriginalName = '--organizations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Password                   = @{ OriginalName = '--password'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Phones                     = @{ OriginalName = '--phones'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PosixAccounts              = @{ OriginalName = '--posixAccounts'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            PrimaryEmail               = @{ OriginalName = '--primaryEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RecoveryEmail              = @{ OriginalName = '--recoveryEmail'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            RecoveryPhone              = @{ OriginalName = '--recoveryPhone'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Relations                  = @{ OriginalName = '--relations'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            SshPublicKeys              = @{ OriginalName = '--sshPublicKeys'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Suspended                  = @{ OriginalName = '--suspended'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [switch]; NoGap = $False }
            UserKey                    = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            Websites                   = @{ OriginalName = '--websites'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "patch"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Updates a user using patch semantics.

.PARAMETER Addresses
Specifies addresses for the user. May be used multiple times in the form of:
'--addresses "country=...;countryCode=..;customType=..."', etc.
You can use the following properties:
country             - Country.
countryCode         - The country code. Uses the ISO 3166-1 standard.
customType          - If the address type is custom, this property contains the custom value.
extendedAddress     - For extended addresses, such as an address that includes a sub-region.
formatted           - A full and unstructured postal address. This is not synced with the structured address fields.
locality            - The town or city of the address.
poBox               - The post office box, if present.
postalCode          - The ZIP or postal code, if applicable.
primary             - BOOL! If this is the user's primary address. The addresses list may contain only one primary address.
region              - The abbreviated province or state.
sourceIsStructured  - BOOL! Indicates if the user-supplied address was formatted. Formatted addresses are not currently supported.
streetAddress       - The street address, such as 1600 Amphitheatre Parkway. Whitespace within the string is ignored; however, newlines are significant.
type                - The address type.
                      Acceptable values are:
                        - "custom"
                        - "home"
                        - "other"
						- "work"


.PARAMETER Archived
Indicates if user is archived.


.PARAMETER ChangePasswordAtNextLogin
Indicates if the user is forced to change their password at next login.
This setting doesn't apply when the user signs in via a third-party identity provider.


.PARAMETER CustomGender
Custom gender.


.PARAMETER Emails
Specifies email addresses for the user. May be used multiple times in the form of:
'--emails "address=...;customType=..;primary=..."', etc.
You can use the following properties:
address     - Country.
customType  - The country code. Uses the ISO 3166-1 standard.
primary     - If the address type is custom, this property contains the custom value.
type        - The type of the email account.
              Acceptable values are:
                - "custom"
                - "home"
                - "other"
                - "work"


.PARAMETER ExternalIds
Specifies externalIds for the user. May be used multiple times in the form of:
'--externalIds "customType=...;type=..;value=..."'
You can use the following properties:
customType  - Country.
type        - The type of the ID.
              Acceptable values are:
                - "account"
                - "custom"
                - "customer"
				- "login_id"
				- "network"
				- "organization": IDs of this type map to employee ID in the Admin Console
value           - The value of the ID.


.PARAMETER FamilyName
The user's last name. Required when creating a user account.


.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER GenderType
Gender.
Acceptable values are:
female
male
other
unknown


.PARAMETER GivenName
The user's first name. Required when creating a user account.


.PARAMETER HashFunction
Stores the hash format of the password property.
We recommend sending the password property value as a base 16 bit hexadecimal-encoded hash value.
Set the hashFunction values as either the SHA-1, MD5, or crypt hash format.


.PARAMETER Ims
The user's Instant Messenger (IM) accounts.
A user account can have multiple ims properties.
But, only one of these ims properties can be the primary IM contact.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--ims "customProtocol=...;customType=..;im=..."', etc.
You can use the following properties:
customProtocol  - If the protocol value is custom_protocol, this property holds the custom protocol's string.
customType      - If the IM type is custom, this property holds the custom type string.
im              - The user's IM network ID.
primary         - BOOL! If this is the user's primary IM. Only one entry in the IM list can have a value of true.
protocol        - An IM protocol identifies the IM network. The value can be a custom network or the standard network.
                  Acceptable values are:
                    - "aim": AOL Instant Messenger protocol
                    - "custom_protocol": A custom IM network protocol
                    - "gtalk": Google Talk protocol
                    - "icq": ICQ protocol
                    - "jabber": Jabber protocol
                    - "msn": MSN Messenger protocol
                    - "net_meeting": Net Meeting protocol
                    - "qq": QQ protocol
                    - "skype": Skype protocol
                    - "yahoo": Yahoo Messenger protocol
type            - The type of the IM account.
                  Acceptable values are:
                   - "custom"
                   - "home"
                   - "other"
                   - "work"


.PARAMETER IncludeInGlobalAddressList
Indicates if the user's profile is visible in the Workspace global address list when the contact sharing feature is enabled for the domain.
For more information about excluding user profiles, see the administration help center.


.PARAMETER IpWhitelisted
If true, the user's IP address is white listed.


.PARAMETER Keywords
The user's keywords. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--keywords "customType=...;type=..;value=..."'
You can use the following properties:
customType  - Custom Type.
type        - Each entry can have a type which indicates standard type of that entry.
              For example, keyword could be of type occupation or outlook.
              In addition to the standard type, an entry can have a custom type and can give it any name.
              Such types should have the CUSTOM value as type and also have a customType value.
              Acceptable values are:
                - "custom"
                - "mission"
                - "occupation"
				- "outlook"
value  -      Keyword.


.PARAMETER Languages
The user's languages. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--languages "customLanguage=..."'
'--languages "languageCode=..."'
You can use the following properties:
customLanguage  - Other language.
				  A user can provide their own language name if there is no corresponding Google III language code.
			      If this is set, LanguageCode can't be set
languageCode    - Language Code.
                  Should be used for storing Google III LanguageCode string representation for language.
				  Illegal values cause SchemaException.


.PARAMETER Locations
The user's locations. The maximum allowed data size for this field is 10Kb.
May be used multiple times in the form of:
'--locations "area=...;buildingId=...;customType=..."', etc.
You can use the following properties:
area          - Textual location.
		        This is most useful for display purposes to concisely describe the location.
		        For example, "Mountain View, CA", "Near Seattle".
buildingId    - Building identifier.
customType    - If the location type is custom, this property contains the custom value.
deskCode      - Most specific textual code of individual desk location.
floorName     - Floor name/number.
floorSection  - Floor section. More specific location within the floor.
                  For example, if a floor is divided into sections "A", "B", and "C", this field would identify one of those values.
type          - The location type.
                Acceptable values are:
                  - "custom"
                  - "default"
				  - "desk"


.PARAMETER NotesContentType
Content type of note, either plain text or HTML.
Default is plain text. Possible values are:
text_plain
text_html


.PARAMETER NotesValue
Contents of notes.


.PARAMETER OrgUnitPath
The full path of the parent organization associated with the user.
If the parent organization is the top-level, it is represented as a forward slash (/).


.PARAMETER Organizations
A list of organizations the user belongs to. The maximum allowed data size for this field is 10Kb.
May be used multiple times in the form of:
'--organizations "costCenter=...;customType=...;department=..."', etc.
You can use the following properties:
costCenter          - The cost center of the user's organization.
customType          - If the value of type is custom, this property contains the custom type.
department          - Specifies the department within the organization, such as 'sales' or 'engineering'.
description         - The description of the organization.
domain              - The domain the organization belongs to.
fullTimeEquivalent  - INT! The full-time equivalent millipercent within the organization (100000 = 100%).	
location            - The physical location of the organization.
			          This does not need to be a fully qualified address.
name                - The name of the organization.
primary             - BOOL! Indicates if this is the user's primary organization.
                      A user may only have one primary organization.
symbol              - Text string symbol of the organization.
                      For example, the text symbol for Google is GOOG.
title               - The user's title within the organization, for example 'member' or 'engineer'.
type                - The type of organization.
                      Acceptable values are:
                        - "domain_only"
                        - "school"
                        - "unknown"
						- "work"


.PARAMETER Password
Stores the password for the user account.
The user's password value is required when creating a user account.
It is optional when updating a user and should only be provided if the user is updating their account password.
A password can contain any combination of ASCII characters.
A minimum of 8 characters is required. The maximum length is 100 characters.
We recommend sending the password property value as a base 16 bit, hexadecimal-encoded hash value.
If a hashFunction is specified, the password must be a valid hash key.
The password value is never returned in the API's response body.


.PARAMETER Phones
A list of the user's phone numbers. The maximum allowed data size for this field is 1Kb.
May be used multiple times in the form of:
'--phones "customType=...;primary=...;type=..."', etc.
You can use the following properties:
customType  - If the value of type is custom, this property contains the custom type.
primary     - BOOL! Indicates if this is the user's primary phone number.
              A user may only have one primary phone number.
type        - The type of phone number.
              Acceptable values are:
                - "assistant"
                - "callback"
                - "car"
                - "company_main"
                - "custom"
                - "grand_central"
                - "home"
                - "home_fax"
                - "isdn"
                - "main"
                - "mobile"
                - "other"
                - "other_fax"
                - "pager"
                - "radio"
                - "telex"
                - "tty_tdd"
                - "work"
                - "work_fax"
                - "work_mobile"
		        - "work_pager"
value       - A human-readable phone number.
			  It may be in any telephone number format.


.PARAMETER PosixAccounts
A list of POSIX account information for the user.
May be used multiple times in the form of:
'--posixAccounts "accountId=...;gecos=...;gid=..."', etc.
You can use the following properties:
accountId            - A POSIX account field identifier.
gecos                - The GECOS (user information) for this account.
gid                  - The default group ID.
homeDirectory        - The path to the home directory for this account.
operatingSystemType  - The operating system type for this account.
                       Acceptable values are:
                         - "linux"
                         - "unspecified"
                         - "windows"
primary              - BOOL! If this is user's primary account within the SystemId.
shell                - The path to the login shell for this account.
systemId             - System identifier for which account Username or Uid apply to.
uid                  - The POSIX compliant user ID.
username             - The username of the account.


.PARAMETER PrimaryEmail
The user's primary email address.
This property is required in a request to create a user account.
The primaryEmail must be unique and cannot be an alias of another user.


.PARAMETER RecoveryEmail
Recovery email of the user.


.PARAMETER RecoveryPhone
Recovery phone of the user.
The phone number must be in the E.164 format, starting with the plus sign (+).
Example: +16506661212.


.PARAMETER Relations
A list of the user's relationships to other users.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--relations "customType=...;type=...;value=..."'
You can use the following properties:
customType  - If the value of type is custom, this property contains the custom type.
type        - The type of relation.
              Acceptable values are:
              - "admin_assistant"
              - "assistant"
              - "brother"
              - "child"
              - "custom"
              - "domestic_partner"
              - "dotted_line_manager"
              - "exec_assistant"
              - "father"
              - "friend"
              - "manager"
              - "mother"
              - "parent"
              - "partner"
              - "referred_by"
              - "relative"
              - "sister"
			  - "spouse"
value       - The name of the person the user is related to.


.PARAMETER SshPublicKeys
A list of SSH public keys.
May be used multiple times in the form of:
'--sshPublicKeys "expirationTimeUsec=...;key=..."'
You can use the following properties:
expirationTimeUsec  - An expiration time in microseconds since epoch.
key                 - An SSH public key.


.PARAMETER Suspended
Indicates if user is suspended.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.


.PARAMETER Websites
The user's websites.
The maximum allowed data size for this field is 2Kb.
May be used multiple times in the form of:
'--websites "customType=...;primary=...;type=..."', etc.
You can use the following properties:
customType  - The custom type. Only used if the type is custom.
primary     - BOOL! If this is user's primary website or not.
type        - The type or purpose of the website.
			  For example, a website could be labeled as home or blog.
			  Alternatively, an entry can have a custom type.
			  Custom types must have a customType value.
			  Acceptable values are:
			    - "app_install_page"
			    - "blog"
			    - "custom"
			    - "ftp"
			    - "home"
			    - "home_page"
			    - "other"
			    - "profile"
			    - "reservations"
			    - "resume"
			    - "work"
value       - The URL of the website.



#>
}


Function SignOut-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "signOut"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Sign a user out of all web and device sessions and reset their sign-in cookies.
User will have to sign in by authenticating again.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Undelete-Users {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$OrgUnitPath,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            OrgUnitPath = @{ OriginalName = '--orgUnitPath'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey     = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "users"
            "undelete"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Undeletes a deleted user.

.PARAMETER OrgUnitPath
The full path of the parent organization associated with the user.
If the parent organization is the top-level, it is represented as a forward slash (/).


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Generate-VerificationCodes {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "verificationCodes"
            "generate"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Generate new backup verification codes for the user.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function Invalidate-VerificationCodes {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "verificationCodes"
            "invalidate"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Invalidate the current backup verification codes for the user.

.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


Function List-VerificationCodes {


    [CmdletBinding()]

    param(
        [Parameter()]
        [string]$Fields,
        [Parameter()]
        [string]$UserKey
    )

    BEGIN {
        $__PARAMETERMAP = @{
            Fields  = @{ OriginalName = '--fields'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
            UserKey = @{ OriginalName = '--userKey'; OriginalPosition = '0'; Position = '2147483647'; ParameterType = [string]; NoGap = $False }
        }

        $__outputHandlers = @{
            Default = @{ StreamOutput = $False; Handler = { $args[0] | ConvertFrom-Json } }
        }
    }
    PROCESS {
        $__commandArgs = @(
            "verificationCodes"
            "list"
            "--compressOutput"
        )
        $__boundparms = $PSBoundParameters
        $MyInvocation.MyCommand.Parameters.Values.Where( { $_.SwitchParameter -and $_.Name -notmatch "Debug|Whatif|Confirm|Verbose" -and ! $PSBoundParameters[$_.Name] }).ForEach( { $PSBoundParameters[$_.Name] = [switch]::new($false) })
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        foreach ($paramName in $PSBoundParameters.Keys | Sort-Object { $__PARAMETERMAP[$_].OriginalPosition }) {
            $value = $PSBoundParameters[$paramName]
            $param = $__PARAMETERMAP[$paramName]
            if ($param) {
                if ( $value -is [switch] ) { $__commandArgs += if ( $value.IsPresent ) { $param.OriginalName } else { $param.DefaultMissingValue } }
                elseif ( $param.NoGap ) { $__commandArgs += "{0}""{1}""" -f $param.OriginalName, $value }
                else { $__commandArgs += $param.OriginalName; $__commandArgs += $value | ForEach-Object { $_ } }
            }
        }
        $__commandArgs = $__commandArgs | Where-Object { $_ }
        if ($PSBoundParameters["Debug"]) { Wait-Debugger }
        if ( $PSBoundParameters["Verbose"]) {
            Write-Verbose -Verbose -Message gsm
            $__commandArgs | Write-Verbose -Verbose
        }
        $__handlerInfo = $__outputHandlers[$PSCmdlet.ParameterSetName]
        if (! $__handlerInfo ) {
            $__handlerInfo = $__outputHandlers["Default"] # Guaranteed to be present
        }
        $__handler = $__handlerInfo.Handler
        if ( $PSCmdlet.ShouldProcess("gsm")) {
            if ( $__handlerInfo.StreamOutput ) {
                & "gsm" $__commandArgs | & $__handler
            }
            else {
                $result = & "gsm" $__commandArgs
                & $__handler $result
            }
        }
    } # end PROCESS

    <#


.DESCRIPTION
Returns the current set of valid backup verification codes for the specified user.

.PARAMETER Fields
Fields allows partial responses to be retrieved.
See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse for more information.


.PARAMETER UserKey
Identifies the user in the API request.
The value can be the user's primary email address, alias email address, or unique user ID.



#>
}


